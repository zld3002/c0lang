A C0VM bytecode file *.bc0 consists of a single structure

We describe the format as pseudo-structs, where use the
types described below.  For multi-byte types, each byte
is given separately by two hexadecimal digits, with the
most significant byte first.  '#' starts a comment that
extends to the end of the line.  For the structs implementing
these, see c0vm.h

u4 - 4 byte unsigned integer
u2 - 2 byte unsigned integer
u1 - 1 byte unsigned integer
i4 - 4 byte signed (two's complement) integer
fi - struct function_info, defined below
ni - struct native_info, defined below

The size of some arrays is variable, depending on earlier fields.
These are only arrays conceptually, of course.  In the file, all the
information is just stored as sequences of bytes separated by
whitespace. For the version number, bit0 = 0 means 32 bit code, bit0 =
1 means 64 bit code.  Bits31-1 indicate the version of the byte code
format, which must be incremented if libraries are changed in
incompatible ways.

struct bc0_file {
  u4 magic;                         # magic number, always 0xc0c0ffee
  u2 version;                       # version number
  u2 int_count;                     # number of integer constants
  i4 int_pool[int_count];           # integer constants
  u2 string_count;                  # number of characters in string pool
  u1 string_pool[string_count];     # adjacent '\0'-terminated strings
  u2 function_count;                # number of functions
  fi function_pool[function_count]; # function info
  u2 native_count;                  # number of native (library) functions
  ni native_pool[native_count];     # native function info
};

struct function_info {
  u2 num_args;                      # number of arguments, V[0..num_args)
  u2 num_vars;                      # number of variables, V[0..num_vars)
  u2 code_length;                   # number of bytes of bytecode
  u1 code[code_length];             # bytecode
};

struct native_info {
  u2 num_args;                      # number of arguments, V[0..num_args)
  u2 function_table_index;          # index into table of library functions
};
