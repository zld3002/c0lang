\newcommand{\rulefmt}[1]{{\small\tt\sc #1}}
\begin{tabular}{lrl}
Struct fields \classpdata

Types \classtaudata

Address \classadata

Values \classvdata

Operators \classopdata

\end{tabular}

\begin{tabular}{lrl}
Expression \classedata

Loop states \classLdata

Call frames \classFdata

Stack frames \classKdata

Directions \classbowtiedata

Foci \classtdata

Variable contexts \startdef{\Gamma}{\emptyparams \OR \varctx{\Gamma}{x}{\tau}}

Memory signatures $\Sigma(a)$ & = & $\tau$ \\

Memory stores $\mu(a)$ & = & $v$ \\

\end{tabular}

First we begin with the judgment \ruletausmalldefaultconclusion{} which determines if a type is permitted to be used as the type of a declaration, parameter of a function, or return type of a function. It specifically excludes structures, functions, non-degenerate tuples and commands.

\begin{mathpar}
\rulecheckvaldefaultconclusion{}
\end{mathpar}

Given a value and a memory signature, this judgment determines a type for the value.  Booleans and integers can be typed without the memory signature but the other types require it so that they do not need to embed any types. The null pointer is allowed to be any pointer type.

\begin{mathpar}
\rulecheckexpdefaultconclusion{}
\end{mathpar}

This judgment determines the type of an expression from a context which describes the variables that are in scope and a signature of the memory. Checking that an expression only uses assigned variables is checked via a separate judgment.

\begin{mathpar}
\rulecanallocdefaultconclusion{}
\end{mathpar}

We must restrict the types which can be allocated to those which are directly expressible in the concrete language. This excludes tuples, commands and functions.

\begin{mathpar}
\rulecheckassigndefaultconclusion{}
\end{mathpar}

Since \langname{} requires variables to be assigned before being used, we use this judgment to determine the set of variables an expression requires to be assigned ($A$) and given that set, which set of variables will be defined after evaluating the expression ($A'$) in a context of declared variables $\Gamma$.

\begin{mathpar}
\rulecheckloopdefaultconclusion{}
\end{mathpar}

This judgment captures the need to restrict expressions such as break and continue to only occur within a loop.

\begin{mathpar}
\ruleonlyreturnsdefaultconclusion{}

\ruledoesreturndefaultconclusion{}

\rulereturnsdefaultconclusion{}
\end{mathpar}

Determining that a function matches its declared return type requires three judgments. The first checks that every possible execution path will, if it returns a value, return a value of the correct type. The second judgment ensures that every possible execution path which reaches the end of the function will return. The third judgment combines the first two and requires that the return type be a small type to be consistent with \langname{}.

\begin{mathpar}
\rulecheckbinopdefaultconclusion{}

\rulecheckmonopdefaultconclusion{}
\end{mathpar}

These two judgments determine the types of the binary and unary operators in the language.

\begin{mathpar}
\rulecheckframetypedefaultconclusion{}
\end{mathpar}

Given a memory signature and a set of assigned variables, we want to know if a (partial) call frame is well formed. This judgment captures the type that the top framelet expects and the type that the call frame will eventually returns.

\begin{mathpar}
\rulegetframecontextdefaultconclusion{}

\rulegetframeassigneddefaultconclusion{}

\rulegetloopcontextdefaultconclusion{}

\rulegetinnerloopdefaultconclusion{}
\end{mathpar}

These four judgments define recursive functions which extract information embedded in the stack. The first determines the typing context of the frame. The second determines which variables have been assigned. The third determines if the current call frame is in the middle of a loop or not. If the call frame is in a loop, the fourth function will return the partial stack frame which indicates the innermost loop.

\begin{mathpar}
\ruleispendingdefaultconclusion{}
\end{mathpar}

Expressions on the stack are always waiting for some value so that they can continue with their evaluation. This judgment captures the type of the expected value ($\tau$), the type that the expression will return once evaluation is complete ($\tau'$), and the return type which the expression will return, if it does return ($\tau''$).

\begin{mathpar}
\ruledirokdefaultconclusion{}
\end{mathpar}

This judgment simply checks if an expression is permitted to be returned to the topmost framelet of the top call frame. Only values and empty tuples are permitted to be returned.

\begin{mathpar}
\rulecheckstackdefaultconclusion{}
\end{mathpar}

We also must check the rest of the stack. Given a value of type $\tau$, evaluation of the call frames will yield a value of type $\tau'$.

\begin{mathpar}
\rulecheckstatedefaultconclusion{}
\end{mathpar}

Typing all these judgments together, we can check that the entire stack $K$ and the focus $t$ are well formed, yielding a final value of type $\tau$. The focus of a stack is an expression (often a subexpression of a function) that is being evalutated, a value that is being used to evaluate a pending expression on the topmost call frame, or an exception which is propagating up the stack.

\begin{mathpar}
\rulefinalstatedefaultconclusion{}
\end{mathpar}

Evaluation is finished when the stack is in a final state. There are no call frames and the focus $t$ is either an exception or a value.

\begin{mathpar}
\ruleevalbinopdefaultconclusion{}

\ruleevalmonopdefaultconclusion{}
\end{mathpar}

These two judgments define the behavior of the binary and unary operators respectively. Binary operators such as \opwrite{} may modify memory and unary operators such as \opread{} may depend on memory but do not modify it. Evaluating an operator is expected to result in a value of the appropriate type but may result in an exception (ex: trying to write a value to \anull{}).

\begin{mathpar}
\ruleallocvaldefaultconclusion{}

\rulemakearraydefaultconclusion{}
\end{mathpar}

These two judgments define functions which perform the allocation of values. Given a heap, an address not in the heap and a type (and a length for arrays), these functions return a new memory containing the appropriate initialized allocations.

\begin{mathpar}
\rulestepdefaultconclusion{}
\end{mathpar}

This judgment defines the transitions between well-typed program states. Evaluation consists of iterating these transitions until a final state is reached.

\begin{mathpar}
\mu : \Sigma

\Sigma \le \Sigma'

\end{mathpar}

The first of these judgments checks that a memory matches the given signature. The second defines a partial relation between signatures which is used to check that memory operations do not destroy or alter any existing allocations.

\section{Rules}

\boxed{\ruletausmalldefaultconclusion}
\begin{mathpar}
\ruletausmallboolnamed

\ruletausmallintnamed

\ruletausmallptrnamed

\ruletausmallarraynamed

\end{mathpar}

\boxed{\rulecheckvaldefaultconclusion}
\begin{mathpar}
\rulecheckvalnopnamed

\rulecheckvaltruenamed

\rulecheckvalfalsenamed

\rulecheckvalintnamed

\rulecheckvaladdressnamed

\rulecheckvalnullnamed

\rulecheckvalarraynamed

\rulecheckvalstructnamed

\rulecheckvalfuncnamed

\end{mathpar}

\boxed{\rulecheckexpdefaultconclusion}
\begin{mathpar}
\rulecheckexpvarnamed

\rulecheckexpvaluenamed

\rulecheckexpbinopnamed

\rulecheckexpmonopnamed

\rulecheckexptuplenamed

\rulecheckexpcallnamed

\rulecheckexpifnamed

\rulecheckexpdeclnamed

\rulecheckexpassignnamed

\rulecheckexpreturnnamed

\rulecheckexploopnamed

\rulecheckexpbreaknamed

\rulecheckexpcontinuenamed

\rulecheckexpallocnamed

\rulecheckexpallocarraynamed

\end{mathpar}

\boxed{\rulecanallocdefaultconclusion}
\begin{mathpar}
\rulecanallocboolnamed

\rulecanallocintnamed

\rulecanallocptrnamed

\rulecanallocarraynamed

\rulecanallocstructnamed

\end{mathpar}
\boxed{\rulecheckassigndefaultconclusion}
\begin{mathpar}
\rulecheckassignvarnamed

\rulecheckassignholenamed

\rulecheckassignvaluenamed

\rulecheckassignbinopnamed

\rulecheckassignmonopnamed

\rulecheckassigntuplenamed

\rulecheckassigncallnamed

\rulecheckassignifnamed

\rulecheckassigndeclnamed

\rulecheckassignassignnamed

\rulecheckassignreturnnamed

\end{mathpar}\begin{mathpar}
\rulecheckassignloopnamed

\rulecheckassignbreaknamed

\rulecheckassigncontinuenamed

\rulecheckassignnopnamed

\rulecheckassignallocnamed

\rulecheckassignallocarraynamed

\end{mathpar}

\boxed{\rulecheckloopdefaultconclusion}
\begin{mathpar}
\rulecheckloopvarnamed

\rulecheckloopvaluenamed

\rulecheckloopbinopnamed

\rulecheckloopmonopnamed

\rulechecklooptuplenamed

\rulecheckloopcallnamed

\rulecheckloopifnamed

\rulecheckloopdeclnamed

\rulecheckloopassignnamed

\rulecheckloopreturnnamed

\rulechecklooploopnamed

\rulecheckloopbreaknamed

\rulecheckloopcontinuenamed

\rulecheckloopnopnamed

\end{mathpar}\begin{mathpar}
\rulecheckloopallocnamed

\rulecheckloopallocarraynamed

\end{mathpar}

\boxed{\ruleonlyreturnsdefaultconclusion}
\begin{mathpar}

\ruleonlyreturnsbinopnamed

\ruleonlyreturnsmonopnamed

\ruleonlyreturnsifnamed

\ruleonlyreturnsdeclnamed

\ruleonlyreturnsassignnamed

\ruleonlyreturnsreturnnamed

\ruleonlyreturnsloopnamed

\ruleonlyreturnsbreaknamed

\ruleonlyreturnscontinuenamed

\ruleonlyreturnsnopnamed

\end{mathpar}
\boxed{\ruledoesreturndefaultconclusion}
\begin{mathpar}
\ruledoesreturnbinoplhsnamed

\ruledoesreturnbinoprhsnamed
\end{mathpar}\begin{mathpar}

\ruledoesreturnifnamed

\ruledoesreturndeclnamed

\ruledoesreturnreturnnamed

\end{mathpar}

\boxed{\rulereturnsdefaultconclusion}
\begin{mathpar}
\rulereturnsonlynamed

\end{mathpar}

\boxed{\rulecheckbinopdefaultconclusion}
\begin{mathpar}
\rulecheckbinopopaddintegernamed

\rulecheckbinopopsubintegernamed

\rulecheckbinopopmulintegernamed

\rulecheckbinopopdivintegernamed

\rulecheckbinopopmodintegernamed

\rulecheckbinopopbitandintegernamed

\rulecheckbinopopbitorintegernamed

\rulecheckbinopopbitxorintegernamed

\rulecheckbinopopshlintegernamed

\rulecheckbinopopshrintegernamed
\end{mathpar}\begin{mathpar}

\rulecheckbinopopcmpgintegernamed

\rulecheckbinopopcmplintegernamed

\rulecheckbinopopcmpgeintegernamed

\rulecheckbinopopcmpleintegernamed

\rulecheckbinopopcmpeqintegernamed

\rulecheckbinopopcmpneintegernamed

\rulecheckbinopopcmpeqboolnamed

\rulecheckbinopopcmpneboolnamed

\rulecheckbinopopcmpeqpointertaunamed

\rulecheckbinopopcmpnepointertaunamed

\rulecheckbinopseqnamed

\rulecheckbinopwritenamed

\rulecheckbinoparrayindexnamed

\end{mathpar}

\boxed{\rulecheckmonopdefaultconclusion}
\begin{mathpar}
\rulecheckmonopopnegintegernamed

\rulecheckmonopoplognotboolnamed

\rulecheckmonopopbitnotintegernamed

\rulecheckmonopignnamed

\rulecheckmonopreadnamed
\end{mathpar}\begin{mathpar}

\rulecheckmonopfieldnamed

\end{mathpar}
\boxed{\rulecheckframetypedefaultconclusion}
\begin{mathpar}
\rulecheckframetypeframeexpnoretnamed

\rulecheckframetypeframeexpretnamed

\rulecheckframetypeframevalnamed

\rulecheckframetypeframevarnamed

\rulecheckframetypeframeloopnamed

\end{mathpar}
\boxed{\rulegetframecontextdefaultconclusion}
\begin{mathpar}
\rulegetframecontextemptynamed

\rulegetframecontextexpnamed

\rulegetframecontextvarnamed

\rulegetframecontextvalnamed

\rulegetframecontextloopnamed

\end{mathpar}
\boxed{\rulegetframeassigneddefaultconclusion}
\begin{mathpar}
\rulegetframeassignedemptynamed

\rulegetframeassignedexpnamed

\rulegetframeassignedvarnamed

\rulegetframeassignedvalnamed

\rulegetframeassignedloopnamed

\end{mathpar}
\boxed{\rulegetloopcontextdefaultconclusion}
\begin{mathpar}
\rulegetloopcontextemptynamed

\rulegetloopcontextdeclnamed

\rulegetloopcontextdefnamed

\rulegetloopcontextexpnamed

\rulegetloopcontextloopnamed

\end{mathpar}
\boxed{\rulegetinnerloopdefaultconclusion}
\begin{mathpar}
\rulegetinnerloopdeclnamed

\rulegetinnerloopdefnamed

\rulegetinnerloopexpnamed

\end{mathpar}\begin{mathpar}
\rulegetinnerlooploopnamed

\end{mathpar}
\boxed{\ruleispendingdefaultconclusion}
\begin{mathpar}
\ruleispendingbinoplnamed

\ruleispendingbinoprnamed

\ruleispendingmonopnamed

\ruleispendingcallfnamed

\ruleispendingcallanamed

\ruleispendingtuplenamed

\ruleispendingifnamed

\ruleispendingassignnamed

\ruleispendingreturnnamed

\ruleispendingallocarraynamed

\end{mathpar}
\boxed{\ruledirokdefaultconclusion}
\begin{mathpar}
\ruledirokpushingnamed

\ruledirokreturningnamed

\rulediroktuplenamed

\end{mathpar}
\boxed{\rulecheckstackdefaultconclusion}
\begin{mathpar}
\rulecheckstackemptynamed

\rulecheckstacknonemptynamed

\end{mathpar}
\boxed{\rulecheckstatedefaultconclusion}
\begin{mathpar}
\rulecheckstateexnnamed

\rulecheckstateemptynamed

\rulecheckstatenormalnamed

\rulecheckstatereturnsnamed

\rulecheckstateloopbrknamed

\rulecheckstateloopcontnamed

\end{mathpar}
\boxed{\rulefinalstatedefaultconclusion}
\begin{mathpar}
\rulefinalstateexnnamed

\rulefinalstatevalnamed

\end{mathpar}

\boxed{\ruleallocvaldefaultconclusion}\\
Here we use the syntax $[\mu | a : v]$ to indicate a new function $\mu'(a') = $ if $a' = a$ then $v$ else $\mu(a')$
\begin{mathpar}
\ruleallocvalboolnamed

\ruleallocvalintnamed

\ruleallocvalptrnamed

\ruleallocvalarraynamed

\ruleallocvalemptystructnamed

\ruleallocvalstructnamed

\end{mathpar}
\boxed{\rulemakearraydefaultconclusion}
\begin{mathpar}
\rulemakearrayemptynamed

\rulemakearraynonemptynamed

\end{mathpar}

\boxed{\ruleevalbinopdefaultconclusion}
Most of the rules for this judgment are elided for brevity as they have clear semantics from the prose description in Chapter 2.
\begin{mathpar}
\inferrule*{ }{\ruleevalbinop{\mu}{\opdiv}{\intliteral{n}}{\intliteral{0}}{\mu}{\exn}}

\inferrule*{ }{\ruleevalbinop{\mu}{\opmod}{\intliteral{n}}{\intliteral{0}}{\mu}{\exn}}

\inferrule*{n > m}{\ruleevalbinop{\mu}{\opcmpg}{\intliteral{n}}{\intliteral{m}}{\mu}{\true}}

\inferrule*{n \le m}{\ruleevalbinop{\mu}{\opcmpg}{\intliteral{n}}{\intliteral{m}}{\mu}{\false}}

\inferrule*{ }{\ruleevalbinop{\mu}{\opseq}{\nop}{\nop}{\mu}{\nop}}

\inferrule*{ a \not\in \dom{\mu} }{\ruleevalbinop{\mu}{\opwrite}{\address{a}}{v}{\mu}{\exn}}

\inferrule*{ a \in \dom{\mu} }{\ruleevalbinop{\mu}{\opwrite}{\address{a}}{v}{[\mu{} |\ a:v]}{v}}

\inferrule*{ 0 < i < n }{\ruleevalbinop{\mu}{\oparrayindex}{\arrayval{a}{n}}{\intliteral{i}}{\mu}{\address{\arrayoffset{a}{i}}}}

\inferrule*{ i < 0 }{\ruleevalbinop{\mu}{\oparrayindex}{\arrayval{a}{n}}{\intliteral{i}}{\mu}{\exn}}

\inferrule*{ i \ge n }{\ruleevalbinop{\mu}{\oparrayindex}{\arrayval{a}{n}}{\intliteral{i}}{\mu}{\exn}}

\end{mathpar}
\boxed{\ruleevalmonopdefaultconclusion}
As with the previous judgment, many of the inference rules are omitted.
\begin{mathpar}
\inferrule*{ }{\ruleevalmonop{\mu}{\oplognot}{\false}{\true}}

\inferrule*{ }{\ruleevalmonop{\mu}{\oplognot}{\true}{\false}}

\inferrule*{ }{\ruleevalmonop{\mu}{\opign}{v}{\nop}}

\inferrule*{ a \not\in \dom{\mu}}{\ruleevalmonop{\mu}{\opread}{\address{a}}{\exn}}

\inferrule*{\mu(a) = v}{\ruleevalmonop{\mu}{\opread}{\address{a}}{v}}

\inferrule*{ }{\ruleevalmonop{\mu}{\opfield{f}}{\structval{a}}{\address{\fieldoffset{a}{f}}}}

\end{mathpar}
\boxed{\rulestepdefaultconclusion}
\begin{mathpar}
\rulestepvalnamed

\rulestepvarnamed

\rulesteppushbinopnamed

\rulestepswapbinopnamed

\rulesteppopbinopnamed

\rulesteppushmonopnamed

\rulesteppopmonopnamed

\rulesteppushcallfnnamed

\rulesteppushcallargsnamed

\rulestepfinalizecall{}\\
\text{\rulefmt{\rulestepfinalizecallname}}

\rulestepcallnullnamed

\end{mathpar}\begin{mathpar}

\rulesteppushemptytuplenamed

\rulesteppushtupleelemnamed

\rulestepnexttupleelemnamed

\rulesteplasttupleelemnamed

\rulestepallocnamed

\rulesteppushallocarraynamed

\rulesteppopallocarraynamed

\rulesteppopallocarrayerrnamed

\rulesteppushifnamed

\rulesteppopiftruenamed

\rulesteppopiffalsenamed

\rulesteppushdeclnamed

\rulesteppopdeclnamed

\rulesteppushassignnamed

\rulesteppopassignnamed

\rulesteppopassignfirstnamed

\rulesteppopassignednamed
\end{mathpar}\begin{mathpar}

\rulesteppushretnamed

\rulesteppopretnamed

\rulesteploopnamed

\rulesteplooppopnamed

\rulestepbreaknamed

\rulestepbreakvalnamed

\rulestepbreakvarnamed

\rulestepbreakloopnamed

\rulestepbreakexpnamed

\rulestepcontinuenamed

\rulestepcontinuevalnamed

\rulestepcontinuevarnamed

\end{mathpar}\begin{mathpar}

\rulestepcontinueloopnamed

\rulestepcontinueexpnamed

\rulestepexnpropnamed

\end{mathpar}

\boxed{\mu : \Sigma}
\begin{mathpar}
\memcheck{\mu}{\Sigma}
\end{mathpar}

\boxed{\Sigma \le \Sigma'}
\begin{mathpar}
\sigcheck{\Sigma}{\Sigma'}
\end{mathpar}

\section{Safety}

\newcommand{\ruleref}[1]{Rule \rulefmt{#1}}
\newcommand{\impliesab}[2]{$#1 \Rightarrow #2$}
\newcommand{\impliescmdreturn}[5]{\impliesab{#1 = \commandty}{\ruleonlyreturns{#2}{#3}{#4}{#5}}}
\newcommand{\impliescmdreturndefault}{\impliescmdreturn{\tau'}{\Sigma}{\Gamma}{e}{\tau''}}
\newcommand{\impliescmdreturnsimple}[1]{\impliescmdreturn{\tau'}{\Sigma}{\Gamma}{#1}{\tau''}}
\newcommand{\expandedG}{\varctx{\varctx{\cdot}{x_1}{\tau_1},\ldots}{x_n}{\tau_n}}

\subsection{Progress}

\progresstheorem{}

\subsection{Preservation}

\preservationtheorem{}

\section{Lemmas}

\begin{enumerate}
\item \label{lemmaassigned} If \rulegetframeassigneddefaultconclusion\ and $x \in A$ then $F$ has the form \frameexp{\frameval{F'}{x}{\tau_x}{v}}{\ldots}. \\
Proof is by induction on the derivation of \rulegetframeassigneddefaultconclusion{}.

\item \label{cfl} If \rulecheckvaldefaultconclusion{} then
\begin{enumerate}
\item If $\tau = \commandty$ then $v = \nop$.
\item If $\tau = \bool$ then either $v = \true$ or $v = \false$.
\item If $\tau = \integer$ then $v = \intliteral{n}$ for some $n \in [-2^{31},2^{31})$.
\item If $\tau = \function{\tuple{\tau_1, \ldots, \tau_n}}{\tau}$ then $v = \func{x_1, \ldots, x_n, e}$ where \rulecheckvalfuncpremisea, \rulecheckvalfuncpremiseb, \rulecheckvalfuncpremised, \rulecheckvalfuncpremisee, \rulecheckvalfuncpremisef, \rulecheckvalfuncpremiseg, \rulecheckvalfuncpremiseh, and \ruletausmall{\tau_1} \ldots{} \ruletausmall{\tau_n}.
\item If $\tau = \pointer{\tau}$ then either $v = \address{\anull}$ or $v = \address{a}$ where \rulecheckvaladdresspremisea
\item If $\tau = \arraytype{\tau}$ then $v = \arrayval{a}{n}$ such that $\forall i \in [0,n).\Sigma(a+i) = \tau$.
\item If $\tau = \struct{p}$ then $v = \structval{a}$ where \rulecheckvalstructpremisea.
\end{enumerate}

Proof is by inversion on the rules for \rulecheckval{\Sigma}{v}{\tau}.

\item \label{binopprogress} If $\mu : \Sigma$ and \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau} and \rulecheckval{\Sigma}{v_1}{\tau_1} and \rulecheckval{\Sigma}{v_2}{\tau_2} then \ruleevalbinopdefaultconclusion{}

  Proof by case analysis on the derivation of \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau}.

\item \label{monopprogress} If $\mu : \Sigma$ and \rulecheckmonop{op}{\tau}{\tau'} and $\rulecheckval{\Sigma}{v}{\tau}$ then \ruleevalmonopdefaultconclusion{}

  Proof by case analysis of the derivation of \rulecheckmonop{op}{\tau}{\tau'}.

\item \label{stackvarshape} If \rulegetframecontext{\Sigma}{F}{\Gamma,x:\tau} then either $F$ has the form \frameexp{\framevar{F'}{x}{\tau}}{\ldots} or the form \frameexp{\frameval{F'}{x}{\tau}{v}}{\ldots} where \rulecheckvaldefaultconclusion

  Proof by case analysis of the derivation of \rulegetframecontext{\Sigma}{F}{\Gamma,x:\tau}.

\item \label{allocprogress} If \rulecanalloc{\tau} and $a \not\in \dom{\mu}$ then $\exists \mu' . \ruleallocval{\mu}{a}{\tau}{\mu'}$.

  Proof by induction on $\tau$.

\item \label{allocarrayprogress} If \rulecanalloc{\tau} and $a \not\in \dom{\mu}$ and $n \ge 0$ then $\exists \mu' . \rulemakearray{\mu}{a}{\tau}{n}{\mu'}$.

  Proof by induction on $n$.

\item \label{allocpres} If \rulecanalloc{\tau} and $a \not\in \dom{\mu}$ and \ruleallocval{\mu}{a}{\tau}{\mu'} then $\exists \Sigma'. \mu' : \Sigma'$ and $\Sigma \le \Sigma'$ and $\Sigma'(a) = \tau$.

  Proof by induction on $\tau$.

\item \label{allocarraypres} If \rulecanalloc{\tau} and $a \not\in \dom{\mu}$ and $n \ge 0$ and \rulemakearray{\mu}{a}{\tau}{n}{\mu'} then $\exists \Sigma'.\mu' : \Sigma'$ and $\Sigma \le \Sigma'$ and \rulecheckval{\Sigma'}{\arrayval{a}{n}}{\arraytype{\tau}}.

  Proof by induction on $n$.

\item \label{allocsafety} If \rulecheckstate{\Sigma}{K}{\tau}{\bowtie}{e} and $\Sigma \le \Sigma'$ then \rulecheckstate{\Sigma'}{K}{\tau}{\bowtie}{e} \\

  Proof is by induction on the derivation of \rulecheckstate{\Sigma}{K}{\tau}{\bowtie}{e} with lots of auxiliary induction.

\item \label{ependingcmd}
  If \ruleispending{\Sigma}{\Gamma}{e}{\commandty}{\tau}{\tau''} then $\tau = \commandty{}$ and $e = \binop{\opseq}{e_1}{e_2}$

  Proof by case analysis on the derivation of \ruleispending{\Sigma}{\Gamma}{e}{\commandty}{\tau}{\tau''}

  \begin{description}
  \item[\rulelemmacmdispendingbinopl] \ \\
    \vspace{-1.1em}
    \begin{tabbing}
     $op = \opseq$ and $\tau = \commandty$ \` Inversion on \rulecheckbinop{op}{\commandty}{\tau''}{\tau} \\
    \end{tabbing}
  \item[\rulelemmacmdispendingbinopr] \ \\
    \vspace{-1.1em}
    \begin{tabbing}
     $op = \opseq$ and $\tau = \commandty$ \` Inversion on \rulecheckbinop{op}{\commandty}{\tau''}{\tau} \\
    \end{tabbing}
  \end{description}
  No other cases can occur.

\item \label{innerloopcheck}
  If \rulegetloopcontext{F}{\inloop} and \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau}
  then \rulegetinnerloop{F}{\frameloop{F'}{e_c}{e}}, \rulegetframeassigned{F'}{A'} and \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau} for some $e_c$, $e$, $F'$, and $A'$.

  Proof by induction on the structure of $F$:
  \begin{description}
  \item[$F = \framevar{F_0}{x}{\tau_{x}}$] \ \\
    \vspace{-1.8em}
    \begin{tabbing}
    \rulecheckframetype{\Sigma}{A' - \{x\}}{F_0}{\commandty}{\tau}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau} \\
    \rulegetloopcontext{F_0}{\frameloop{F'}{e_c}{e}} and \rulegetframeassigned{F'}{A'} \\
    and \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau}
      \` By inductive hypothesis \\
    \rulegetloopcontext{F}{\frameloop{F'}{e_c}{e}}
      \` \ruleref{\rulegetloopcontextdeclname} \\
    \end{tabbing}
  \item[$F = \frameval{F_0}{x}{\tau_x}{v}$] \ \\
    \vspace{-1.8em}
    \begin{tabbing}
    \rulecheckframetype{\Sigma}{A' - \{x\}}{F_0}{\commandty}{\tau}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau} \\
    \rulegetinnerloop{F_0}{\frameloop{F'}{e_c}{e}} and \rulegetframeassigned{F'}{A'} \\
    and \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau}
      \` By inductive hypothesis \\
    \rulegetloopcontext{F}{\frameloop{F'}{e_c}{e}}
      \` \ruleref{\rulegetloopcontextdefname} \\
    \end{tabbing}
  \item[$F = \frameexp{F_0}{e}$] \ \\
    \vspace{-1.8em}
    \begin{tabbing}
    \rulecheckassign{\Gamma}{A}{e}{A''} and \ruleispending{\Sigma}{\Gamma}{e}{\commandty}{\tau'}{\tau''} \\
      \` By inversion on \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau} \\
    $\tau' = \commandty$
      \` By Lemma \ref{ependingcmd} \\
    \rulecheckframetype{\Sigma}{A''}{F}{\commandty}{\tau}
      \` By inversion on \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau} \\
    \rulegetloopcontext{F_0}{\inloop} \\
      \` By inversion on the derivation of \rulegetloopcontext{F}{\inloop} \\
    \rulegetinnerloop{F_0}{\frameloop{F'}{e_c}{e}} and \rulegetframeassigned{F'}{A'} \\
    and \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau}
      \` By inductive hypothesis \\
    \rulegetinnerloop{F}{\frameloop{F'}{e_c}{e}}
      \` \ruleref{\rulegetinnerloopexpname} \\
    \end{tabbing}
  \item[$F = \frameloop{F_0}{e_c}{e}$] \ \\
    \vspace{-1.8em}
    \begin{tabbing}
    \rulegetinnerloop{F}{\frameloop{F_0}{e_c}{e}}
      \` \ruleref{\rulegetinnerlooploopname} \\
    \rulegetframeassigned{F'}{A'} and \rulecheckframetype{\Sigma}{A'}{F}{\commandty}{\tau}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau} \\
    \end{tabbing}
  \end{description}

\item \label{binoppres} If \rulecheckbinopdefaultconclusion{} and $\mu : \Sigma$ and \ruleevalbinopdefaultconclusion{} then $\mu' : \Sigma$ and either $t = \exn{}$ or else $t = v$ and \rulecheckvaldefaultconclusion{}.

  Proof by case analysis on the derivation of \ruleevalbinopdefaultconclusion{}

\item \label{monoppres} If \rulecheckmonopdefaultconclusion{} and $\mu : \Sigma$ and \ruleevalmonopdefaultconclusion{} then either $t = \exn{}$ or else $t = v$ and \rulecheckvaldefaultconclusion{}.

  Proof by case analysis on the derivation of \ruleevalmonopdefaultconclusion{}

\item \label{constructctx} If $\Gamma = \expandedG$ and $\forall i \in [1,n]. \Sigma \entails v_i : \tau_i$ and $F = \frameval{\frameexp{\frameval{\cdot}{x_1}{\tau_1}{v_1}}{\ldots}}{x_n}{\tau_n}{v_n}$ then \rulegetframecontextdefaultconclusion{} \\

  Proof by induction on the structure of $F$.

\item \label{constructA} If $A = \{x_1, \ldots, x_n\}$ and $F = \frameval{\frameexp{\frameval{\cdot}{x_1}{\tau_1}{v_1}}{\ldots}}{x_n}{\tau_n}{v_n}$ then \rulegetframeassigneddefaultconclusion{} \\

  Proof by induction on the structure of $F$.

\item \label{extendAassign}
  If \rulecheckassign{\expandedG}{A_1}{e}{A_2} and $A_1 \subseteq A_1' \subseteq \{x_1,\ldots,x_n\}$
  then \rulecheckassign{\expandedG}{A_1'}{e}{A_2'} where $A_2 \subseteq A_2' \subseteq \{x_1,\ldots,x_n\}$

  Proof by induction on the derivation of \rulecheckassign{\expandedG}{A_1}{e}{A_2}.

\item \label{extendAframetype}
  If \rulecheckframetypedefaultconclusion{} and \rulegetframecontext{\Sigma}{F}{\expandedG} and $A \subseteq A' \subseteq \{x_1,\ldots,x_n\}$
  then \rulecheckframetype{\Sigma}{A'}{F}{\tau}{\tau'}

  Proof by induction on the derivation of \rulecheckframetypedefaultconclusion{}.

\item \label{assignfirstassigned}
  If $F = F_0,x:\tau_x,\ldots$ and \rulecheckval{\Sigma}{v}{\tau_x} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulegetframeassigned{F}{A}
  then \rulegetframeassigned{F'}{A \cup \{x\}}

  Proof by induction on the structure of $F$.
\item \label{assignassigned}
  If $F = F_0,x=v',\ldots$ and \rulecheckval{\Sigma}{v'}{\tau_v} and \rulecheckval{\Sigma}{v}{\tau_v} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulegetframeassigned{F}{A}
  then \rulegetframeassigned{F'}{A}

  Proof by induction on the structure of $F$.

\item \label{assignfirstctx}
  If $F = F_0,x:\tau_x,\ldots$ and \rulecheckval{\Sigma}{v}{\tau_x} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulegetframecontext{\Sigma}{F}{\Gamma}
  then \rulegetframecontext{\Sigma}{F'}{\Gamma}

  Proof by induction on the structure of $F$.
\item \label{assignctx}
  If $F = F_0,x:\tau_x=v',\ldots$ and \rulecheckval{\Sigma}{v'}{\tau_v} and \rulecheckval{\Sigma}{v}{\tau_v} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulegetframecontext{\Sigma}{F}{\Gamma}
  then \rulegetframecontext{\Sigma}{F'}{\Gamma}

  Proof by induction on the structure of $F$.

\item \label{assignfirstframetype}
  If $F = F_0,x:\tau_x,\ldots$ and \rulecheckval{\Sigma}{v}{\tau_x} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulecheckframetype{\Sigma}{A}{F}{\tau}{\tau'}
  then \rulecheckframetype{\Sigma}{A}{F'}{\tau}{\tau'}

  Proof by induction on the structure of $F$.

\item \label{assignframetype}
  If $F = F_0,x:\tau_x=v',\ldots$ and \rulecheckval{\Sigma}{v'}{\tau_x} and \rulecheckval{\Sigma}{v}{\tau_x} and $F' = F_0,x:\tau_x=v,\ldots$ and \rulecheckframetype{\Sigma}{A}{F}{\tau}{\tau'}
  then \rulecheckframetype{\Sigma}{A}{F'}{\tau}{\tau'}

  Proof by induction on the structure of $F$.

\item \label{assignexpand}
  If \rulecheckassign{\Gamma}{A}{e}{A'} then $A \subseteq A'$.

  Proof by induction on the derivation of \rulecheckassign{\Gamma}{A}{e}{A'}.

\item \label{loopsub}
  If \rulecheckloop{L}{e} then \rulecheckloop{\inloop}{e}.

  Proof by induction on the derivation of \rulecheckloop{L}{e}.

\end{enumerate}

\section{Proofs}

\subsection{Progress}
\label{progressproof}

Proof by case analysis on the derivation of \rulecheckstatedefaultconclusion.

\newcommand{\progressruleused}[2]{Case \rulefmt{#1} was used so #2}

\begin{enumerate}

\item \progressruleused{\rulecheckstateexnname}{$t = \exn$}

  Via case analysis of the structure of $K$ either
  \begin{enumerate}
  \item Case $K = \emptystack$
    \begin{tabbing}
    \rulefinalstateexnconclusion{}
      \` \ruleref{\rulefinalstateexnname} \\
    \end{tabbing}

  \item Case $K = \stackframe{K'}{F}$
    \begin{tabbing}
    \ruleKPrimestepexnpropconclusion{}
      \` \ruleref{\ruleKPrimestepexnpropname} \\
    \end{tabbing}

  \end{enumerate}

\item \progressruleused{\rulecheckstateemptyname}{$K = \emptystack$}

  \begin{tabbing}
  \rulefinalstatevalconclusion{}
    \` \ruleref{\rulefinalstatevalname} \\
  \end{tabbing}

\item \progressruleused{\ruleKPrimecheckstatenormalname}{$K = \stackframe{K'}{F}$ and $t = e$ and \ruleKPrimecheckstatenormalpremiseb{}} \ \\
  We now do a case analysis on \ruleKPrimecheckstatenormalpremiseb{}:

  \begin{enumerate}

  \item \progressruleused{\ruleprogressmodifiedtauandgammacheckexpvarname}{$e = x$} \ \\

    \begin{tabbing}
    \rulecheckassignvarpremisea \` Inversion on \rulecheckassign{\Gamma}{A}{x}{A} \\
    $F = \frameexp{\frameval{F'}{x}{\tau_x}{v}}{\ldots}$ \` Lemma \ref{lemmaassigned} \\
    \ruleKPrimeFPrimestepvarconclusion{}
      \` \ruleref{\rulestepvarname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpvaluename}{$e = v$} \ \\

    Via case analysis of \ruledirokdefaultconclusion{} we know that either \rulefmt{\ruleeisvdirokpushingname} or \rulefmt{\ruleeisvdirokreturningname} was used. \\

    In the former case, \rulefmt{\rulestepvalname} applies.
    For the latter, we must case analyze \ruleKPrimecheckstatenormalpremiseg:\\

    \begin{enumerate}
    \item \progressruleused{\ruleKPrimecheckframetypeframeloopname}{$F = \frameloop{F'}{e_c}{e'}$ for some $F'$, $e_c$ and $e'$} \ \\

      \begin{tabbing}
      $v = \nop$
        \` Lemma \ref{cfl} \\
      \ruleKPrimeFPrimesteplooppopconclusion{} \\
        \` \ruleref{\rulesteplooppopname} \\
      \end{tabbing}

    \item \progressruleused{\ruleKPrimecheckframetypeframevarname}{$F = \framevar{F'}{x}{\tau_x}$ for some $F'$, $x$ and $\tau_x$} \ \\
      \begin{tabbing}
      $v = \nop$
        \` Lemma \ref{cfl} \\
      \ruleKPrimeFPrimesteppopdeclconclusion{}
        \` \ruleref{\rulesteppopdeclname} \\
      \end{tabbing}

    \item \progressruleused{\ruleKPrimecheckframetypeframevalname}{$F = \frameval{F'}{x}{\tau_x}{v}$ for some $F'$, $x$, $\tau_x$ and $v$} \ \\
      \begin{tabbing}
      $v = \nop$
        \` Lemma \ref{cfl} \\
      \ruleKPrimeFPrimesteppopassignedconclusion{}
        \` \ruleref{\rulesteppopassignedname} \\
      \end{tabbing}

    \item \progressruleused{\ruleKPrimeFPrimecheckframetypeframeexpretname}{$F = \frameexp{F'}{e'}$ for some $F'$ and $e'$} \ \\
      We must now case analysis on the derivation of \ruledoesreturn{e'}:
      \begin{enumerate}

      \item \progressruleused{\ruledoesreturnreturnname}{$e' = \return{e''}$} \ \\
        \begin{tabbing}
        $e'' = \cdot$
          \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\commandty}{\tau''} \\
        \ruleKPrimeFPrimesteppopretconclusion{}
          \` \ruleref{\rulesteppopretname} \\
        \end{tabbing}

      \item \progressruleused{\ruledoesreturnifname}{$e' = \ifexp{e_c}{e_t}{e_f}$} \ \\
        \begin{tabbing}
        \hspace{1em} \= \kill
        $e_c = \cdot$ and $\tau' = \bool$
          \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\commandty}{\tau''} \\
        $v = \true$ or $v = \false$
          \` Lemma \ref{cfl} \\
        If $v = \true$ then \+ \\
          \ruleKPrimeFPrimesteppopiftrueconclusion{} \\
            \` \ruleref{\rulesteppopiftruename} \- \\
        Otherwise $v = \false$ so \+ \\
          \ruleKPrimeFPrimesteppopiffalseconclusion{} \\
            \` \ruleref{\rulesteppopiffalsename} \- \\
        \end{tabbing}

      \item \progressruleused{\ruledoesreturnbinoprhsname}{$e' = \binop{\opseq}{e_1}{e_2}$} \ \\

        \begin{tabbing}
        $e_2 \not= \cdot$
          \` Via case analysis we know there is no derivation of \ruledoesreturn{\cdot} \\
        $e_1 = \cdot$
          \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\commandty}{\tau''} \\
        \ruleKPrimeFPrimestepswapbinopconclusion{} \\
          \` \ruleref{\rulestepswapbinopname} \\
        \end{tabbing}

      \item \progressruleused{\ruledoesreturnbinoplhsname}{$e' = \binop{\opseq}{e_1}{e_2}$}  \ \\

        \begin{tabbing}
        $e_1 \not= \cdot$
          \` Via case analysis we know there is no derivation of \ruledoesreturn{\cdot} \\
        $e_2 = \cdot$ and $e_1 = v'$ for some $v'$ \\
          \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\commandty}{\tau''} \\
        This case does not occur. \\
          \` Via case analysis we know there is no derivation of \ruledoesreturn{v'} \\
        \end{tabbing}

      \item \progressruleused{\ruledoesreturndeclname}{$e' = \decl{x}{\tau_x}{e''}$}

        This case does not occur because via case analysis we know there is no derivation of \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\commandty}{\tau''}

      \end{enumerate}

    \item \progressruleused{\ruleKPrimeFPrimecheckframetypeframeexpnoretname}{$F = \frameexp{F'}{e'}$ for some $F'$ and $e'$} \ \\
      We now do a case analysis of \ruleispending{\Sigma}{\Gamma}{e'}{\tau'}{\tau'''}{\tau''}

      \begin{enumerate}

      \item \progressruleused{\ruleKPrimeFPrimeispendingbinoplname}{$e' = \binop{op}{\cdot}{e_2}$} \ \\

        \begin{tabbing}
        \ruleKPrimeFPrimestepswapbinopconclusion{} \\
          \` \ruleref{\rulestepswapbinopname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingbinoprname}{$e' = \binop{op}{v'}{\cdot}$} \ \\

        \begin{tabbing}
        \ruleevalbinop{\mu}{op}{v}{v'}{\mu'}{t}
          \` Lemma \ref{binopprogress} \\
        \ruleKPrimeFPrimesteppopbinopconclusion{}
          \` \ruleref{\rulesteppopbinopname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingmonopname}{$e' = \monop{op}{\cdot}$} \ \\

        \begin{tabbing}
        \ruleevalmonopdefaultconclusion{}
          \` Lemma \ref{monopprogress} \\
        \ruleKPrimeFPrimesteppopmonopconclusion{}
          \` \ruleref{\rulesteppopmonopname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingcallfname}{$e' = \call{\cdot}{e_a}$} \ \\

        \begin{tabbing}
        \ruleKPrimeFPrimesteppushcallargsconclusion{} \\
          \` \ruleref{\rulesteppushcallargsname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingtuplename}{$e' = \tupleexp{v_1,\ldots,v_{i-1},\cdot,e_{i+1},\ldots,e_n}$} \ \\
        Case analysis on the structure of \tupleexp{v_1,\ldots,v_{i-1},\cdot,e_{i+1},\ldots,e_n}
        \begin{itemize}
        \item $n = i$
          \begin{tabbing}
          \ruleKPrimeFPrimesteplasttupleelemconclusion{} \\
            \` \ruleref{\rulesteplasttupleelemname} \\
          \end{tabbing}

        \item $n > i$
          \begin{tabbing}
          \ruleKPrimeFPrimestepnexttupleelemconclusion{} \\
            \` \ruleref{\rulestepnexttupleelemname} \\
          \end{tabbing}

        \end{itemize}

      \item \progressruleused{\ruleKPrimeFPrimeispendingifname}{$e' = \ifexp{\cdot}{e_t}{e_f}$} \ \\
        Clearly $\tau' = \bool$.

        \begin{tabbing}
        \hspace{2em} \= \kill
        $v = \true$ or $v = \false$
          \` Lemma \ref{cfl} \\
        If $v = \true$ then \+ \\
          \ruleKPrimeFPrimesteppopiftrueconclusion{} \\
            \` \ruleref{\rulesteppopiftruename} \- \\
        Otherwise $v = \false$ so \+ \\
          \ruleKPrimeFPrimesteppopiffalseconclusion{} \\
            \` \ruleref{\rulesteppopiffalsename} \- \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingassignname}{$e' = \assign{x}{\cdot}$} \ \\

        \begin{tabbing}
        \hspace{2em} \= \kill
        We know that either $F'$ has the form \frameexp{\framevar{F''}{x}{\tau'}}{\ldots} or it has the form \\
            \frameexp{\frameval{F''}{x}{\tau_x}{v'}}{\ldots}
          \` Lemma \ref{stackvarshape} \\
        In the former case, \\
          \prgstate{\mu}{\stackframe{K'}{\frameexp{\frameexp{\framevar{F''}{x}{\tau'}}{\ldots}}{\assign{x}{\cdot}}}}{\lhd}{v}
            $\rightarrow$ \+ \\
          \prgstate{\mu}{\stackframe{K'}{\frameexp{\frameval{F''}{x}{\tau_x}{v}}{\ldots}}}{\lhd}{\nop} \-
            \` \ruleref{\rulesteppopassignfirstname} \\
        In the latter case, \\
          \prgstate{\mu}{\stackframe{K'}{\frameexp{\frameexp{\frameval{F''}{x}{\tau'}{v'}}{\ldots}}{\assign{x}{\cdot}}}}{\lhd}{v}
            $\rightarrow$ \+ \\
          \prgstate{\mu}{\stackframe{K'}{\frameexp{\frameval{F''}{x}{\tau_x}{v}}{\ldots}}}{\lhd}{\nop} \-
            \` \ruleref{\rulesteppopassignname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingreturnname}{$e' = \return{e''}$} \ \\

        \begin{tabbing}
        \ruleKPrimeFPrimesteppopretconclusion{}
          \` \ruleref{\rulesteppopretname} \\
        \end{tabbing}

      \item \progressruleused{\ruleKPrimeFPrimeispendingallocarrayname}{$e' = \allocarrayexp{\tau_a}{\cdot}$} \ \\
        \begin{tabbing}
        \hspace{2em} \= \kill
        $v = \intliteral{n}$
          \` Lemma \ref{cfl} \\
        If $n \ge 0$ then \+ \\
          \ruleKPrimeFPrimesteppopallocarraypremiseb{}
            \` Lemma \ref{allocarrayprogress} \\
          \ruleKPrimeFPrimesteppopallocarrayconclusion{} \\
            \` \ruleref{\rulesteppopallocarrayname} \- \\
        Otherwise, \ruleKPrimeFPrimesteppopallocarrayerrconclusion{} \\
          \` \ruleref{\rulesteppopallocarrayerrname} \\
        \end{tabbing}

      \end{enumerate}

    \end{enumerate}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpbinopname}{$e = \binop{op}{e_1}{e_2}$} \ \\

    \begin{tabbing}
    $\bowtie = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\binop{op}{e_1}{e_2}} \\
    \ruleKPrimesteppushbinopconclusion{} \\
      \` \ruleref{\rulesteppushbinopname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpmonopname}{$e = \monop{op}{e'}$} \ \\

    \begin{tabbing}
    $\bowtie = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\monop{op}{e_a}} \\
    \ruleKPrimesteppushmonopconclusion{}
      \` \ruleref{\rulesteppushmonopname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexptuplename}{$e = \tupleexp{e_1, \ldots, e_n}$} \ \\

    We do a case analysis on \ruleprogresstupledirokdefaultconclusion:
    \begin{enumerate}
    \item \progressruleused{\ruleprogresstupledirokpushingname}{$\bowtie = \rhd$} \ \\

      \begin{tabbing}
      \hspace{2em} \= \kill
      If $n = 0$ then \+ \\
        \ruleKPrimesteppushemptytupleconclusion{}
          \` \ruleref{\rulesteppushemptytuplename} \- \\
      Otherwise \+
        \ruleKPrimesteppushtupleelemconclusion{} \\
          \` \ruleref{\rulesteppushtupleelemname} \- \\
      \end{tabbing}

    \item \progressruleused{\ruleprogresstupledirokreturningname}{$\bowtie = \lhd$ and $e = v$} \ \\

      Does not occur since there is no derivation of \rulecheckval{\Sigma}{v}{\tuple{\tau_1,\ldots,\tau_n}}.

    \item \progressruleused{\ruleprogresstuplediroktuplename}{$\bowtie = \lhd$ and $e = \tupleexp{v_1,\ldots,v_n}$} \ \\
      We do a case analysis on the derivation of \ruleprogresstuplecheckframetypedefaultconclusion{}

      \begin{enumerate}

      \item \progressruleused{\ruleprogresstuplecheckframetypeframeexpnoretname}{$F' = \frameexp{F''}{e'}$} \ \\
        \begin{tabbing}
        \hspace{3em} \= \hspace{3em} \= \kill
        There are three possible derivations of \\
          \` \ruleispending{\Sigma}{\Gamma}{e'}{\tupleexp{\tau_1,\ldots,\tau_n}}{\tau'''}{\tau''}. \\
        Case \rulefmt{\ruleispendingreturnname}: \+ \\
          $e' = \return{\cdot}$ and \ruletausmall{\tuple{\tau_1,\ldots,\tau_n}} \\
            \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tupleexp{\tau_1,\ldots,\tau_n}}{\tau'''}{\tau''}. \\
          $n = 0$
            \` Inversion on \ruletausmall{\tuple{\tau_1,\ldots,\tau_n}} \\
          \rulestep{\mu}{K'}{\frameexp{F'}{\return{\cdot}}}{\lhd}{\tupleexp{}}
                   {\mu}{K'}{\lhd}{\tupleexp{}}
            \` \ruleref{\rulesteppopretname} \- \\
        Case \rulefmt{\ruleispendingmonopname} where $op = \opign$: \+ \\
          $e' = \monop{\opign, \cdot}$ and $\opign : \tuple{\tau_1,\ldots,\tau_n} \rightarrow \commandty$ \\
            \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tupleexp{\tau_1,\ldots,\tau_n}}{\tau'''}{\tau''}. \\
          \ruletausmall{\tuple{\tau_1,\ldots,\tau_n}} \\
            \` Inversion on $\opign : \tuple{\tau_1,\ldots,\tau_n} \rightarrow \commandty$ \\
          $n = 0$
            \` Inversion on \ruletausmall{\tuple{\tau_1,\ldots,\tau_n}} \\
          \ruleevalmonop{\mu}{\opign}{\tupleexp{}}{t}
            \` Lemma \ref{monopprogress} \\
          \ruleKPrimeFPrimesteppopmonopconclusion{} \\
            \` \ruleref{\rulesteppopmonopname} \- \\
        Otherwise \rulefmt{\ruleispendingcallaname} was used: \+ \\
          $e' = \call{\address{a}, \cdot{}}$ and
          \rulecheckval{\Sigma}{\address{a}}{\pointer{(\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau'''})}} \\
            \` Inversion on \ruleispending{\Sigma}{\Gamma}{e'}{\tupleexp{\tau_1,\ldots,\tau_n}}{\tau'''}{\tau''}. \\
          $\Sigma(a) = \function{\tuple{\tau_1, \ldots, \tau_n}}{\tau'''}$ \\
            \` Inversion on \rulecheckval{\Sigma}{\address{a}}{\pointer{\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau'''}}} \\
          $\mu(a) = v$ and \rulecheckval{\Sigma}{v}{\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau'''}} \` $\mu : \Sigma$ \\
          $v = \func{x_1, \ldots, x_n, e_b}$ \` Lemma \ref{cfl} \\
          \prgstate{\mu}{K'}{\frameexp{F'}{\call{\address{a},\cdot}}}{\lhd}{\tupleexp{v_1,\ldots,v_n}} $\rightarrow$ \+ \\
            \prgstate{\mu}{\stackframe{\stackframe{K'}{F'}}{\frameval{\frameexp{\frameval{\cdot}{x_1}{\tau_1}{v_1}}{\ldots}}{x_n}{\tau_n}{v_n}}}{\rhd}{e_b} \- \\
            \` \ruleref{\rulestepfinalizecallname} \\
        \\
        \end{tabbing}
      \item \progressruleused{\ruleprogresstuplecheckframetypeframeexpretname}{$F' = \frameexp{F''}{e'}$} \ \\
        Progress holds via the same reasoning as in the previous case though only the \rulefmt{\ruleispendingreturnname} case occurs since there are no derivations of \ruledoesreturn{e'} for the other cases.

      \end{enumerate}

    \end{enumerate}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpcallname}{$e = \call{e_f, e}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\call{e_f, e_a}} \\
    \ruleKPrimesteppushcallfnconclusion{}
      \` \ruleref{\rulesteppushcallfnname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpifname}{$e = \ifexp{e_c}{e_t}{e_f}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\ifexp{e_c}{e_t}{e_f}} \\
    \ruleKPrimesteppushifconclusion
      \` \ruleref{\rulesteppushifname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpdeclname}{$e = decl{x}{\tau_x}{e'}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\decl{x}{\tau_x}{e'}} \\
    \ruleprogressmodifiedtausteppushdeclconclusion
      \` \ruleref{\rulesteppushdeclname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpassignname}{$e = \assign{x}{e'}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\assign{x}{e'}} \\
    \ruleKPrimesteppushassignconclusion
      \` \ruleref{\rulesteppushassignname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpreturnname}{$e = \return{e'}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\return{e'}} \\
    \ruleKPrimesteppushretconclusion
      \` \ruleref{\rulesteppushretname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexploopname}{$e = \loopstm{e_c}{e}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\loopstm{e_c}{e'}} \\
    \ruleKPrimesteploopconclusion \\
      \` \ruleref{\rulesteploopname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpbreakname}{$e = \breakstm$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
      \` Inversion on \ruledirok{\bowtie}{\breakstm} \\
    \ruleKPrimestepbreakconclusion
      \` \ruleref{\rulestepbreakname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpcontinuename}{$e = \continue$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
     \` Inversion on \ruledirok{\bowtie}{\continue} \\
    \ruleKPrimestepcontinueconclusion
      \` \ruleref{\rulestepcontinuename} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpallocname}{$e = \allocexp{\tau_a}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
     \` Inversion on \ruledirok{\bowtie}{\allocexp{\tau_a}} \\
    \ruleallocval{\mu}{a}{\tau_a}{\mu'}
      \` Lemma \ref{allocprogress} \\
    \ruleKPrimestepallocconclusion
      \` \ruleref{\rulestepallocname} \\
    \end{tabbing}

  \item \progressruleused{\ruleprogressmodifiedtaucheckexpallocarrayname}{$e = \allocarrayexp{\tau_a}{e'}$} \ \\

    \begin{tabbing}
    $\bowtie{} = \rhd$
     \` Inversion on \ruledirok{\bowtie}{\allocarrayexp{\tau_a}{e'}} \\
    \rulestep{\mu}{K'}{F}{\rhd}{\allocarrayexp{\tau_a}{e'}}{\mu}{\stackframe{K'}{\frameexp{F}{\allocarrayexp{\tau_a}{\cdot}}}}{\rhd}{e'} \\
      \` \ruleref{\rulesteppushallocarrayname} \\
    \end{tabbing}

  \end{enumerate} % e : \tau'

\item Case \rulefmt{\ruleKPrimecheckstatereturnsname} was used \ \\
  By inversion on \rulereturns{\Sigma}{\Gamma}{e}{\tau''} we know \ruledoesreturndefaultconclusion{}
  so by case analysis, $e$ is one of the following:
  \begin{itemize}
  \item \ruledoesreturnbinoplhsconclusion{}
  \item \ruledoesreturnbinoprhsconclusion{}
  \item \ruledoesreturnifconclusion{}
  \item \ruledoesreturndeclconclusion{}
  \item \ruledoesreturnreturnconclusion{}
  \end{itemize}

  These cases are handled exactly the same as if the rule used in the derivation was
  \rulefmt{\ruleKPrimecheckstatenormalname}.

\item \progressruleused{\ruleKPrimecheckstateloopbrkname}{$K = \stackframe{K'}{F}$} \ \\

  We now do case analysis on the structure of $F$:

  \begin{description}
  \item[$F=\framevar{F'}{x}{\tau_x}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepbreakvarconclusion{}
      \` \ruleref{\rulestepbreakvarname} \\
    \end{tabbing}
  \item[$F=\frameval{F'}{x}{\tau_x}{v}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepbreakvalconclusion{}
      \` \ruleref{\rulestepbreakvalname} \\
    \end{tabbing}
  \item[$F=\frameloop{F'}{e_c}{e}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepbreakloopconclusion{}
      \` \ruleref{\rulestepbreakloopname} \\
    \end{tabbing}
  \item[$F=\frameexp{F'}{e}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepbreakexpconclusion{}
      \` \ruleref{\rulestepbreakexpname} \\
    \end{tabbing}
  \end{description}

\item \progressruleused{\ruleKPrimecheckstateloopcontname}{$K = \stackframe{K'}{F}$} \ \\

  We now do case analysis on the structure of $F$:

  \begin{description}
  \item[$F=\framevar{F'}{x}{\tau_x}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepcontinuevarconclusion{}
      \` \ruleref{\rulestepcontinuevarname} \\
    \end{tabbing}
  \item[$F=\frameval{F'}{x}{\tau_x}{v}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepcontinuevalconclusion{} \\
      \` \ruleref{\rulestepcontinuevalname} \\
    \end{tabbing}
  \item[$F=\frameloop{F'}{e_c}{e}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepcontinueloopconclusion{} \\
      \` \ruleref{\rulestepcontinueloopname} \\
    \end{tabbing}
  \item[$F=\frameexp{F'}{e}$] \ \\
    \begin{tabbing}
    \ruleKPrimeFPrimestepcontinueexpconclusion{}
      \` \ruleref{\rulestepcontinueexpname} \\
    \end{tabbing}
  \end{description}

\end{enumerate} % K d t : \tau

\subsection{Preservation}
\label{preservationproof}

Proof by induction on the derivation of \rulestepdefaultconclusion. The cases where $\Sigma' \not= \Sigma$ are noted explicitly.

\begin{description}

\item[\rulestepval] \ \\
\newcommand{\presvalunwind}{\rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{v}}
\begin{tabbing}
\rulegetframecontextdefaultconclusion{} \` Inversion on \presvalunwind \\
\rulecheckexp{\Sigma}{\Gamma}{v}{\tau'} \` Inversion on \presvalunwind \\
\rulegetframeassigneddefaultconclusion  \` Inversion on \presvalunwind \\
\rulecheckassignvalueconclusion{}       \` Inversion on \presvalunwind \\
\rulegetloopcontextdefaultconclusion    \` Inversion on \presvalunwind \\
\rulecheckloopvalueconclusion           \` Inversion on \presvalunwind \\
\rulecheckframetype{\Sigma}{A}{F}{\tau'}{\tau'''} \` Inversion on \presvalunwind \\
\rulecheckstack{\Sigma}{K}{\tau''}{\tau}\` Inversion on \presvalunwind \\
\impliescmdreturnsimple{v}              \` Inversion on \presvalunwind \\
\ruledirok{\lhd}{v}                     \` \ruleref{\ruledirokreturningname} \\
\rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{v} \` \ruleref{\rulecheckstatenormalname} \\
\end{tabbing}

\item[\rulestepvar] \ \\
\newcommand{\varframe}{\frameexp{\frameval{F}{x}{\tau_x}{v}}{\ldots}}
\newcommand{\presvarunwind}{\rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{x}}
\begin{tabbing}
\rulegetframecontext{\Sigma}{\varframe}{\Gamma} \` Inversion on \presvarunwind \\
\rulecheckexp{\Sigma}{\Gamma}{x}{\tau'} \` Inversion on \presvarunwind \\
\rulegetframeassigned{\varframe}{A}     \` Inversion on \presvarunwind \\
\rulecheckassignvarconclusion{}         \` Inversion on \presvarunwind \\
\rulegetloopcontext{\varframe}{L}       \` Inversion on \presvarunwind \\
\rulecheckframetype{\Sigma}{A}{\varframe}{\tau'}{\tau''} \` Inversion on \presvarunwind \\
$\Gamma = \varctx{\Gamma'}{x}{\tau'}$   \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'} \\
\rulecheckexp{\Sigma}{\Gamma}{v}{\tau'} \` Lemma \ref{stackvarshape} \\
\rulecheckloopvalueconclusion           \` \ruleref{\rulecheckloopvaluename} \\
\rulecheckstack{\Sigma}{K}{\tau''}{\tau}\` Inversion on \presvarunwind \\
If $\tau' = \commandty$, $v = \nop$ 
  \` Lemma \ref{cfl} \\
\impliescmdreturnsimple{v} \\
  \` \ruleonlyreturns{\Sigma}{\Gamma}{\nop}{\tau''} by rule \rulefmt{\ruleonlyreturnsnopname} \\
\ruledirok{\lhd}{v}                     \` \ruleref{\ruledirokreturningname} \\
\rulecheckstate{\Sigma}{\stackframe{K}{\varframe}}{\tau}{\lhd}{v} \` \ruleref{\rulecheckstatenormalname} \\
\end{tabbing}

\item[\rulesteppushbinop] \ \\
  \newcommand{\presbinopunwind}{\rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\binop{op}{e_1}{e_2}}}
  \newcommand{\presbinopF}{\frameexp{F}{\binop{op}{\cdot}{e_2}}}

  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \kill
  \rulegetframecontextdefaultconclusion{}
    \` Inversion on \presbinopunwind \\
  \rulegetframeassigneddefaultconclusion
    \` Inversion on \presbinopunwind \\
  \rulecheckassignbinopconclusion{}
    \` Inversion on \presbinopunwind \\
  \rulegetloopcontextdefaultconclusion
    \` Inversion on \presbinopunwind \\
  \rulecheckloopbinopconclusion
    \` Inversion on \presbinopunwind \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \presbinopunwind \\
  % Unpack exp
  \rulecheckexp{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau'}
    \` Inversion on \presbinopunwind \\
  \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'} and \rulecheckexp{\Sigma}{\Gamma}{e_1}{\tau_1} and \rulecheckexp{\Sigma}{\Gamma}{e_2}{\tau_2} \\
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau'} \\
  % Unpack assign
  \rulecheckassign{\Gamma}{A}{e_1}{A'} and \rulecheckassign{\Gamma}{A'}{e_2}{A''}
    \` Inversion on \rulecheckassignbinopconclusion \\
  \rulecheckassign{\Gamma}{A'}{\cdot}{A'}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A'}{\binop{op}{\cdot}{e_2}}{A''}
    \` \ruleref{\rulecheckassignbinopname} \\
  % Unpack loop
  \rulecheckloop{L}{e_1} and \rulecheckloop{L}{e_2}
    \` Inversion on \rulegetloopcontext{L}{\binop{op}{e_1}{e_2}} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\binop{op}{\cdot}{e_2}}
    \` \ruleref{\rulecheckloopbinopname} \\
  % show inner frame
  If the rule used for \presbinopunwind{} was {\tt \rulecheckstatenormalname} then \+ \\
    \rulecheckframetype{\Sigma}{A''}{F}{\tau'}{\tau'''}
      \` Inversion on \presbinopunwind \\
    \impliescmdreturnsimple{\binop{op}{e_1}{e_2}} \\
      \` Inversion on \presbinopunwind \\
    \impliesab{\tau' = \commandty}{\ruleonlyreturns{\Sigma}{\Gamma}{e_1}{\tau''}} and
    \impliesab{\tau' = \commandty}{\ruleonlyreturns{\Sigma}{\Gamma}{e_2}{\tau''}} \\
      \` Inversion on \impliescmdreturnsimple{\binop{op}{e_1}{e_2}} \\
    If $\tau' = \commandty$ then $op = \opseq, \tau_1 = \commandty, $ and $\tau_2 = \commandty$ \\
      \` Inversion on \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'} \\
    $\tau' = \commandty \Leftrightarrow \tau_1 = \commandty \Leftrightarrow \tau_2 = \commandty \Leftrightarrow op = \opseq$ \\
      \` By case analysis of the rules for \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'} \\
    \pushtabs
    Thus \= \impliesab{\tau_1 = \commandty}{\ruleonlyreturns{\Sigma}{\Gamma}{e_1}{\tau''}} and \+ \\
            \impliesab{\tau_2 = \commandty}{\ruleonlyreturns{\Sigma}{\Gamma}{e_2}{\tau''}} \- \\
    \poptabs
    % show pending
    \ruleispending{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau_1}{\tau'}{\tau''}
      \` \ruleref{\ruleispendingbinoplname} \\
    \rulecheckframetype{\Sigma}{A'}{\presbinopF}{\tau_1}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
    \rulegetframecontext{\Sigma}{\presbinopF}{\Gamma}
      \` \ruleref{\rulegetframecontextexpname} \\
    \rulegetframeassigned{\presbinopF}{A}
      \` \ruleref{\rulegetframeassignedexpname} \\
    \rulegetloopcontext{\presbinopF}{L}
      \` \ruleref{\rulegetloopcontextexpname} \\
    % show direction ok
    \ruledirok{\rhd}{e_1}
      \` \ruleref{\ruledirokpushingname} \\
    % DONE!
    \rulecheckstate{\Sigma}{\stackframe{K}{\presbinopF}}{\tau}{\rhd}{e_1}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise the {\tt \rulecheckstatereturnsname} rule was used. \+ \\
    \rulereturns{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau''} \\
      \` Inversion on \presbinopunwind{} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau''} and \ruledoesreturn{\binop{op}{e_1}{e_2}} and \\
      \hspace{1em} \ruletausmall{\tau''} \\
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau''} \\
    $L = \notinloop$
      \` Inversion on \presbinopunwind{} \\
    $\tau' = \commandty$
      \` Inversion on \presbinopunwind{} \\
    $\tau' = \commandty \Leftrightarrow \tau_1 = \commandty \Leftrightarrow \tau_2 = \commandty \Leftrightarrow op = \opseq$ \\
      \` By case analysis of the rules for \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'} \\
    Via case analysis on \ruledoesreturn{\binop{op}{e_1}{e_2}}, there are two possibilities. \\
    Case \ruledoesreturn{e_1} \+ \\
      \ruleonlyreturns{\Sigma}{\Gamma}{e_1}{\tau''} \\
        \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau''} \\
      \rulereturns{\Sigma}{\Gamma}{e_1}{\tau''}
        \` \ruleref{\rulereturnsdefaultname} \\
      \rulegetframecontext{\Sigma}{\presbinopF}{\Gamma}
        \` \ruleref{\rulegetframecontextexpname} \\
      \rulegetframeassigned{\presbinopF}{A}
        \` \ruleref{\rulegetframeassignedexpname} \\
      \rulegetloopcontext{\presbinopF}{\notinloop} \\
        \` \ruleref{\rulegetloopcontextexpname} \\
      \ruledirok{\rhd}{e_1}
        \` \ruleref{\ruledirokpushingname} \\
      \rulecheckstate{\Sigma}{\stackframe{K}{\presbinopF}}{\tau}{\rhd}{e_1}
        \` \ruleref{\rulecheckstatereturnsname} \- \\
    Case \ruledoesreturn{e_2} \+ \\
      \ruleonlyreturns{\Sigma}{\Gamma}{e_2}{\tau''} \\
        \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\binop{op}{e_1}{e_2}}{\tau''} \\
      \impliescmdreturn{\tau_2}{\Sigma}{\Gamma}{e_2}{\tau''}
        \` Weakening \\
      % show pending
      \ruleispending{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau_1}{\tau'}{\tau''}
        \` \ruleref{\ruleispendingbinoplname} \\
      \ruledoesreturn{\binop{op}{\cdot}{e_2}}
        \` \ruleref{\ruledoesreturnbinoprhsname} \\
      \rulereturns{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau''}
        \` \ruleref{\rulereturnsdefaultname} \\
      \rulecheckframetype{\Sigma}{A'}{\presbinopF}{\tau_1}{\tau''} \\
        \` \ruleref{\rulecheckframetypeframeexpretname} \\
      \rulegetframecontext{\Sigma}{\presbinopF}{\Gamma}
        \` \ruleref{\rulegetframecontextexpname} \\
      \rulegetframeassigned{\presbinopF}{A}
        \` \ruleref{\rulegetframeassignedexpname} \\
      \rulegetloopcontext{\presbinopF}{L}
        \` \ruleref{\rulegetloopcontextexpname} \\
      % show direction ok
      \ruledirok{\rhd}{e_1}
        \` \ruleref{\ruledirokpushingname} \\
      % DONE!
      \rulecheckstate{\Sigma}{\stackframe{K}{\presbinopF}}{\tau}{\rhd}{e_1}
        \` \ruleref{\rulecheckstatenormalname} \- \\
  \end{tabbing}

\item[\rulestepswapbinop] \ \\
  \newcommand{\swapbinopstackpre}{\frameexp{F}{\binop{op}{\cdot}{e_2}}}
  \newcommand{\swapbinopstack}{\frameexp{F}{\binop{op}{v}{\cdot}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \kill
  \rulegetframecontext{\Sigma}{\swapbinopstackpre}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{v}{\tau_1}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\swapbinopstackpre}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulegetloopcontext{\swapbinopstackpre}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulecheckloop{L}{v}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstackpre}}{\tau}{\lhd}{v} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{\binop{op}{\cdot}{e_2}}{A'}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
  \ruleispending{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau_1}{\tau'}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
  \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
  \impliescmdreturn{\tau_2}{\Sigma}{\Gamma}{e_2}{\tau''} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau_1}{\tau'}{\tau''} \\
  \rulecheckexp{\Sigma}{\Gamma}{e_2}{\tau_2}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\binop{op}{\cdot}{e_2}}{\tau_1}{\tau'}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{e_2}{A'}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\binop{op}{\cdot}{e_2}}{A} \\
  \\
  There are two possible rules used for the derivation of \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
  Case \rulefmt{\rulecheckframetypeframeexpnoretname} \+ \\
    \rulecheckframetype{\Sigma}{A'}{F}{\tau'}{\tau''}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    \rulecheckassign{\Gamma}{A'}{\cdot}{A'}
      \` \ruleref{\rulecheckassignholename} \\
    \rulecheckassign{\Gamma}{A'}{v}{A'}
      \` \ruleref{\rulecheckassignvaluename} \\
    \rulecheckassign{\Gamma}{A'}{\binop{op}{v}{\cdot}}{A'}
      \` \ruleref{\rulecheckassignbinopname} \\
    \rulegetloopcontext{F}{L}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    \rulecheckloop{L}{\cdot}
      \` \ruleref{\rulecheckloopvarname} \\
    \rulecheckloop{L}{\binop{op}{v}{\cdot}}
      \` \ruleref{\rulecheckloopbinopname} \\
    \rulecheckval{\Sigma}{v}{\tau_1}
      \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{v}{\tau_1} \\
    \ruleispending{\Sigma}{\Gamma}{\binop{op}{v}{\cdot}}{\tau_2}{\tau'}{\tau''}
      \` \ruleref{\ruleispendingbinoprname} \\
    \rulecheckframetype{\Sigma}{A'}{\swapbinopstack}{\tau_2}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
    \\
    \rulegetframecontext{\Sigma}{\swapbinopstack}{\Gamma}
      \` \ruleref{\rulegetframecontextexpname} \\
    \rulegetframeassigned{F}{A}
      \` Inversion on \rulegetframeassigned{\swapbinopstackpre}{A} \\
    \rulegetframeassigned{\swapbinopstack}{A}
      \` \ruleref{\rulegetframeassignedexpname} \\
    \rulegetloopcontext{\swapbinopstack}{L}
      \` \ruleref{\rulegetloopcontextexpname} \\
    \rulecheckloop{L}{\binop{op}{\cdot}{e_2}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    \rulecheckloop{L}{e_2}
      \` Inversion on \rulecheckloop{L}{\binop{op}{\cdot}{e_2}} \\
    \ruledirok{\rhd}{e_2}
      \` \ruleref{\ruledirokpushingname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstack}}{\tau}{\rhd}{e_2}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise \rulefmt{\rulecheckframetypeframeexpretname} was used \+ \\
    \ruledoesreturn{\binop{op}{\cdot}{e_2}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    \rulegetloopcontext{F}{\notinloop}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    \rulecheckloop{\notinloop}{\binop{op}{\cdot}{e_2}} \\
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    $\tau' = \commandty$
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\swapbinopstackpre}{\tau_1}{\tau''} \\
    $\tau' = \commandty \Leftrightarrow \tau_2 = \commandty \Leftrightarrow op = \opseq$ \\
    \rulegetframecontext{\Sigma}{\swapbinopstack}{\Gamma}
      \` \ruleref{\rulegetframecontextexpname} \\
    \rulegetframeassigned{\swapbinopstack}{A}
      \` \ruleref{\rulegetframeassignedexpname} \\
    \rulegetloopcontext{\swapbinopstack}{\notinloop}
      \` \ruleref{\rulegetloopcontextexpname} \\
    \rulecheckloop{\notinloop}{e_2}
      \` Inversion on \rulecheckloop{\notinloop}{\binop{op}{\cdot}{e_2}} \\
    \ruledirok{\rhd}{e_2}
      \` \ruleref{\ruledirokpushingname} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{e_2}{\tau''}
      \` Modus ponens \\
    \rulereturns{\Sigma}{\Gamma}{e_2}{\tau''}
      \` \ruleref{\rulereturnsonlyname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\swapbinopstack}}{\tau}{\rhd}{e_2}
      \` \ruleref{\rulecheckstatereturnsname} \\
  \end{tabbing}


\item[\rulesteppopbinop] \ \\
\newcommand{\popbinopstack}{\frameexp{F}{\binop{op}{v_1}{\cdot}}}
\newcommand{\presbinoppop}{\rulecheckstate{\Sigma}{\stackframe{K}{\popbinopstack}}{\tau}{\rhd}{v_2}}
\begin{tabbing}
\rulegetframecontext{\Sigma}{\popbinopstack}{\Gamma}
  \` Inversion on \presbinoppop \\
\rulecheckexp{\Sigma}{\Gamma}{v_2}{\tau_2}
  \` Inversion on \presbinoppop \\
\rulegetframeassigned{\popbinopstack}{A}
  \` Inversion on \presbinoppop \\
\rulecheckassign{\Gamma}{A}{v_2}{A}
  \` Inversion on \presbinoppop \\
\rulegetloopcontext{\binop{op}{v_1}{\cdot}}{L}
  \` Inversion on \presbinoppop \\
\rulecheckstack{\Sigma}{K}{\tau''}{\tau}
  \` Inversion on \presbinoppop \\
\rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'}
  \` Inversion on \presbinoppop \\
\\
\rulegetframecontext{\Sigma}{F}{\Gamma}
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\rulegetframeassigned{F}{A}
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\rulecheckassign{\Gamma}{A}{\binop{op}{v}{\cdot}}{A}
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\rulegetloopcontext{F}{L}
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\rulecheckframetype{\Sigma}{A}{F}{\tau'}{\tau''}
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\ruleispending{\Sigma}{\Gamma}{\binop{op}{v_1}{\cdot}}{\tau_2}{\tau'}{\tau''} \\
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\popbinopstack}{\tau_2}{\tau'} \\
\rulecheckexp{\Sigma}{\Gamma}{v}{\tau_1} and \rulecheckbinop{op}{\tau_1}{\tau_2}{\tau'} \\
  \` Inversion on \ruleispending{\Sigma}{\Gamma}{\binop{op}{v_1}{\cdot}}{\tau_2}{\tau'}{\tau''} \\
\ruleevalbinopdefaultconclusion{}
  \` Inversion on \rulesteppopbinopconclusion{} \\
$\mu' : \Sigma$ and either $t = \exn{}$ or else $t = v'$ and \rulecheckval{\Sigma}{v'}{\tau'}
  \` Lemma \ref{binoppres} \\
If $t = \exn{}$ then \rulecheckstateexnconclusion{}
  \` \ruleref{\rulecheckstateexnname} \\
Otherwise, $t = v'$ and \rulecheckval{\Sigma}{v'}{\tau'} \\
\rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'}
  \` \ruleref{\rulecheckexpvaluename} \\
\rulecheckassign{\Gamma}{A}{v'}{A}
  \` \ruleref{\rulecheckassignvaluename} \\
\rulecheckloop{L}{v'}
  \` \ruleref{\rulecheckloopvaluename} \\
\ruledirokreturningconclusion{}
  \` \ruleref{\ruledirokreturningname} \\
If $\tau' = \commandty$ then $v' = \nop$
  \` Lemma \ref{cfl} \\
\impliescmdreturn{\tau'}{\Sigma}{\Gamma}{v'}{\tau''}
  \` \ruleonlyreturns{\Sigma}{\Gamma}{\nop}{\tau''} \\
\rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{v'}
  \` \ruleref{\rulecheckstatenormalname} \\

\end{tabbing}

\item[\rulesteppushmonop] \ \\
  \newcommand{\monopstack}{\frameexp{F}{\monop{op}{\cdot}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\monop{op}{e}}{\tau'''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulecheckassign{\Gamma}{A}{\monop{op}{e}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulecheckloop{L}{\monop{op}{e}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tau'''}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\monop{op}{e}} \\
  \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\monop{op}{\cdot}}{A}
    \` \ruleref{\rulecheckassignmonopname} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\monop{op}{\cdot}}
    \` \ruleref{\rulecheckloopmonopname} \\
  \rulecheckmonop{op}{\tau'}{\tau'''}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\monop{op}{e}}{\tau'''} \\
  \ruleispending{\Sigma}{\Gamma}{\monop{op}{\cdot}}{\tau'}{\tau'''}{\tau''}
    \` \ruleref{\ruleispendingmonopname} \\
  \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau'''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  \rulegetframecontext{\Sigma}{\monopstack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\monop{op}{e}}{\tau'''} \\
  \rulegetframeassigned{\monopstack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulecheckassign{\Gamma}{A}{e}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\monop{op}{e}}{A} \\
  \rulecheckloop{L}{e}
    \` Inversion on \rulecheckloop{L}{\monop{op}{e}} \\
  \ruledirok{\rhd}{e}
    \` \ruleref{\ruledirokpushingname} \\
  $\tau' \not= \commandty$
    \` Inversion on \rulecheckmonop{op}{\tau'}{\tau'''} \\
  \impliescmdreturnsimple{\tau'}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\rhd}{e}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteppopmonop] \ \\
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \kill
  \rulegetframecontext{\Sigma}{\monopstack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{v}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\monopstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\monopstack}}{\tau}{\lhd}{v} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulegetframecontext{\Sigma}{\monopstack}{\Gamma} \\
  \rulecheckassign{\Gamma}{A}{\monop{op}{\cdot}}{A}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau''} \\
  \ruleispending{\Sigma}{\Gamma}{\monop{op}{\cdot}}{\tau'}{\tau'''}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tau'''}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\monopstack}{\tau'}{\tau''} \\
  \rulecheckmonop{op}{\tau'}{\tau'''}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\monop{op}{\cdot}}{\tau'}{\tau'''}{\tau''} \\
  Either $t = \exn{}$ or $t = v'$ where \rulecheckval{\Sigma}{v'}{\tau'''}
    \` Lemma \ref{monoppres} \\
  If $t = \exn{}$ \+ \\
    Trivially \rulecheckstateexnconclusion{} \- \\
  Otherwise $t = v'$ where \rulecheckval{\Sigma}{v'}{\tau'''} \+ \\
    \rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'''}
      \` \ruleref{\rulecheckexpvaluename} \\
    \rulegetframeassigned{F}{A}
      \` Inversion on \rulegetframeassigned{\monopstack}{A} \\
    \rulecheckassign{\Gamma}{A}{v'}{A}
      \` \ruleref{\rulecheckassignvaluename} \\
    \rulecheckloop{L}{v'}
      \` \ruleref{\rulecheckloopvaluename} \\
    \ruledirok{\lhd}{v}
      \` \ruleref{\ruledirokreturningname} \\
    If $\tau''' = \commandty$ then $v' = \nop$
      \` Lemma \ref{cfl} \\
    \impliescmdreturn{\tau'''}{\Sigma}{\Gamma}{v}{\tau''}
      \` \ruleonlyreturns{\Sigma}{\Gamma}{\nop}{\tau''} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{v'}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  \end{tabbing}

\item[\rulesteppushcallfn] \ \\

  \newcommand{\pushcallfnstack}{\frameexp{F}{\call{\cdot,e}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\call{e_f,e}}{\tau_r}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulecheckassign{\Gamma}{A}{\call{e_f,e}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulecheckloop{L}{\call{e_f,e}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tau_r}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\call{e_f,e}} \\
  \\
  \rulecheckassign{\Gamma}{A}{e}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\call{e_f,e}}{A} \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\call{\cdot,e}}{A}
    \` \ruleref{\rulecheckassigncallname} \\

  \rulecheckloop{L}{e}
    \` Inversion on \rulecheckloop{L}{\call{e_f,e}} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\call{\cdot,e}}
    \` \ruleref{\rulecheckloopcallname} \\

  \rulecheckexp{\Sigma}{\Gamma}{e}{\tuple{\tau_1, \ldots, \tau_n}}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\call{e_f,e}}{\tau_r} \\
  \ruleispending{\Sigma}{\Gamma}{\call{\cdot,e}}{\pointer{(\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r})}}{\tau_r}{\tau''} \\
    \` \ruleref{\ruleispendingcallfname} \\

  \rulecheckframetype{\Sigma}{A}{\pushcallfnstack}{\pointer{(\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r})}}{\tau''} \\
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  \rulegetframecontext{\Sigma}{\pushcallfnstack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulecheckexp{\Sigma}{\Gamma}{e_f}{\pointer{(\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r})}}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\call{e_f,e}}{\tau_r} \\
  \rulegetframeassigned{\pushcallfnstack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulecheckassign{\Gamma}{A}{e_f}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\call{e_f,e}}{A} \\
  \rulegetloopcontext{\pushcallfnstack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \rulecheckloop{L}{e_f}
    \` Inversion on \rulecheckloop{L}{\call{e_f}{e}} \\
  \ruledirok{\rhd}{e_f}
    \` \ruleref{\ruledirokpushingname} \\
  \impliescmdreturn{\pointer{(\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r})}}{\Sigma}{\Gamma}{e_f}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\pushcallfnstack}}{\tau}{\rhd}{e_f}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppushcallargs] \ \\

  \newcommand{\pushargsstack}{\frameexp{F}{\call{\cdot,e}}}
  \newcommand{\pushargsstackpost}{\frameexp{F}{\call{v,\cdot}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{\pushargsstack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\pushargsstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r} \\
  \ruleispending{\Sigma}{\Gamma}{\call{\cdot,e}}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r} \\
  \rulecheckexp{\Sigma}{\Gamma}{v}{\pointer{(\function{\tau_a}{\tau_r})}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  $v = \address{a}$ where $\Sigma(a) = \function{\tau_a}{\tau_r}$
    \` Lemma \ref{cfl} \\
  \rulecheckexp{\Sigma}{\Gamma}{\address{a}}{\pointer{(\function{\tau_a}{\tau_r})}}
    \` \ruleref{\rulecheckexpvarname} \\
  \ruleispending{\Sigma}{\Gamma}{\call{\address{a}, \cdot}}{\tau_a}{\tau_r}{\tau''}
    \` \ruleref{\ruleispendingcallaname} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r} \\
  \rulecheckloop{L}{\call{v,\cdot}}
    \` \ruleref{\rulecheckloopcallname} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` \ruleref{\rulecheckassignvaluename} \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\call{v,\cdot}}{A}
    \` \ruleref{\rulecheckassigncallname} \\

  \rulecheckframetype{\Sigma}{A}{\pushargsstackpost}{\tau_a}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\

  \rulegetframecontext{\Sigma}{\pushargsstackpost}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulecheckexp{\Sigma}{\Gamma}{e}{\tau_a}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\call{\cdot,e}}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r}{\tau''} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\pushargsstack}{A} \\
  \rulegetframeassigned{\pushargsstackpost}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulecheckassign{\Gamma}{A}{\call{\cdot,e}}{A}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r} \\
  \rulecheckassign{\Gamma}{A}{e}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\call{\cdot,e}}{A} \\
  \rulegetloopcontext{\pushargsstackpost}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \rulecheckloop{L}{\call{\cdot,e}}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushargsstack}{\pointer{(\function{\tau_a}{\tau_r})}}{\tau_r} \\
  \rulecheckloop{L}{e}
    \` Inversion on \rulecheckloop{L}{\call{\cdot,e}} \\
  \ruledirok{\rhd}{e}
    \` \ruleref{\ruledirokpushingname} \\

  $\mu(a) = v_f$ where \rulecheckval{\Sigma}{v_f}{\function{\tau_a}{\tau_r}}
    \` $\mu : \Sigma$ \\
  $v_f = \func{x_1, \ldots, x_n, e'}$
    \` Lemma \ref{cfl} \\
  $\tau_a = \tuple{\tau_1, \ldots, \tau_n}$
    \` Inversion on \rulecheckval{\Sigma}{v_f}{\function{\tau_a}{\tau_r}} \\
  \impliescmdreturn{\tau_a}{\Sigma}{\Gamma}{e}{\tau''}
    \` Vacuously true \\

  \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstackpost}}{\tau}{\rhd}{e}
    \` \ruleref{\rulecheckstatenormalname} \\
%  \rulecheckexp{\Sigma}{\Gamma}{v}{\pointer{(\function{\tau_a}{\tau_r})}}
%    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushargsstack}}{\tau}{\lhd}{v} \\
  \end{tabbing}

\item[\rulestepfinalizecall] \ \\
\newcommand{\newframe}{\frameval{\frameexp{\frameval{\cdot}{x_1}{\tau_1}{v_1}}{\ldots}}{x_n}{\tau_n}{v_n}}
\newcommand{\presfcallunwind}{\rulecheckstate{\Sigma}{\stackframe{K}{\frameexp{F}{\call{\address{a}, \cdot}}}}{\tau}{\lhd}{\tupleexp{v_1, \ldots, v_n}}}

\begin{tabbing}
\hspace{3em} \= \hspace{3em} \= \kill
\rulecheckexp{\Sigma}{\Gamma}{\tupleexp{v_1, \ldots, v_n}}{\tuple{\tau_1, \ldots, \tau_n}} \\
  \` Inversion on \presfcallunwind \\
\rulegetframeassigned{\frameexp{F}{\call{\address{a}, \cdot}}}{A} \\
  \` Inversion on \presfcallunwind \\
\rulecheckassign{\Gamma}{A}{\tupleexp{v_1, \ldots, v_n}}{A} \` Inversion on \presfcallunwind \\
\rulecheckstack{\Sigma}{K}{\tau''}{\tau}\` Inversion on \presfcallunwind \\
% Show call frame
\rulecheckframetype{\Sigma}{A}{\frameexp{F}{\call{\address{a}, \cdot}}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau''} \\
  \` Inversion on \presfcallunwind \\
% Show call doesn't assign
\rulecheckassign{\Gamma}{A}{\call{\address{a}, \cdot}}{A} \\
  \` Inversion on \rulecheckframetype{\Sigma}{A}{\frameexp{F}{\call{\address{a}, \cdot}}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau''} \\
% Unpack pending
\ruleispending{\Sigma}{\Gamma}{\call{\address{a}, \cdot}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r}{\tau''} \\
\` Inversion on \rulecheckframetype{\Sigma}{A}{\frameexp{F}{\call{\address{a}, \cdot}}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau''} \\
% Show type of call
\rulecheckexp{\Sigma}{\Gamma}{\address{a}}{\pointer{\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r}}} \\
\` Inversion on \ruleispending{\Sigma}{\Gamma}{\call{\address{a}, \cdot}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r}{\tau''} \\
% show function value is well typed
\rulecheckval{\Sigma}{\func{x_1, \ldots, x_n, e}}{\function{\tuple{\tau_1, \ldots \tau_n}}{\tau_r}} \\
  \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\address{a}}{\pointer{\function{\tuple{\tau_1, \ldots, \tau_n}}{\tau_r}}} \\
% Show F
\rulecheckframetype{\Sigma}{A}{F}{\tau_r}{\tau''} \` Inversion on \rulecheckframetype{\Sigma}{A}{\frameexp{F}{\call{\address{a}, \cdot}}}{\tuple{\tau_1, \ldots, \tau_n}}{\tau''} \\
% Show assigned(F) = A
\rulegetframeassigned{F}{A}  \` Inversion on \rulegetframeassigned{\frameexp{F}{\call{\address{a}, \cdot}}}{A} \\
% Show K;F
\rulecheckstack{\Sigma}{\stackframe{K}{F}}{\tau_r}{\tau} \` \ruleref{\rulecheckstacknonemptyname} \\
% Show context in new frame
\rulegetframecontext{\Sigma}{\newframe}{\Gamma'} \` Lemma \ref{constructctx} \\
% Show assigned in new frame
\rulegetframeassigned{\newframe}{A'} \` Lemma \ref{constructA} \\
% Show well typed body
\rulecheckexp{\Sigma}{\Gamma}{e}{\commandty}
  \` Inversion on \rulecheckval{\Sigma}{\func{x_1, \ldots, x_n, e}}{\function{\tuple{\tau_1, \ldots \tau_n}}{\tau_r}} \\
% Show body assign
\rulecheckassigndefaultconclusion{}
  \` Inversion on \rulecheckval{\Sigma}{\func{x_1, \ldots, x_n, e}}{\function{\tuple{\tau_1, \ldots \tau_n}}{\tau_r}} \\
% Show loopnest
\rulegetloopcontext{F}{\notinloop} \` By construction \\
% Show loop check
\rulecheckloop{\notinloop}{e}
  \` Inversion on \rulecheckval{\Sigma}{\func{x_1, \ldots, x_n, e}}{\function{\tuple{\tau_1, \ldots \tau_n}}{\tau_r}} \\
% Show returns
\rulereturns{\Sigma}{\Gamma}{e}{\tau_r}
  \` Inversion on \rulecheckval{\Sigma}{\func{x_1, \ldots, x_n, e}}{\function{\tuple{\tau_1, \ldots \tau_n}}{\tau_r}} \\
% show direction
\ruledirok{\rhd}{e} \` \ruleref{\ruledirokpushingname} \\
% Done!
\rulecheckstate{\Sigma}{\stackframe{\stackframe{K}{F}}{\newframe}}{\tau}{\rhd}{e} \` \ruleref{\rulecheckstatereturnsname} \\
\end{tabbing}

\item[\rulestepcallnull] \ \\
  \begin{tabbing}
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\exn{}}
    \` \ruleref{\rulecheckstateexnname} \\
  \end{tabbing}

\item[\rulesteppushemptytuple{}] \ \\

  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\tupleexp{}}{\tuple{}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tuple{}}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \rulecheckloop{L}{\tupleexp{}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{}} \\
  \impliescmdreturn{\tuple{}}{\Sigma}{\Gamma}{\tupleexp{}}{\tau''}
    \` Vacuously true \\
  \ruledirok{\lhd}{\tupleexp{}}
    \` \ruleref{\rulediroktuplename} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\tupleexp{}}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppushtupleelem] \ \\
  \newcommand{\pushtuplestack}{\frameexp{F}{\tupleexp{\cdot,\ldots}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\tupleexp{e_1,\ldots}}{\tuple{\tau_1,\ldots}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{e_1,\ldots}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulecheckloop{L}{\tupleexp{e_1,\ldots}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tuple{\tau_1,\ldots}}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\tupleexp{e_1,\ldots}} \\
  \\
  \rulecheckexp{\Sigma}{\Gamma}{e_1}{\tau_1} \ldots
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\tupleexp{e_1,\ldots}}{\tuple{\tau_1,\ldots}} \\
  \rulecheckassign{\Gamma}{A}{e_1}{A} \ldots
    \` Inversion on \rulecheckassign{\Gamma}{A}{\tupleexp{e_1,\ldots}}{A} \\
  \rulecheckloop{L}{e_1} \ldots
    \` Inversion on \rulecheckloop{L}{\tupleexp{e_1,\ldots}} \\
  \ruletausmall{\tau_1} \ldots
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\tupleexp{e_1,\ldots}}{\tuple{\tau_1,\ldots}} \\
  \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{\cdot,\ldots}}{A}
    \` \ruleref{\rulecheckassigntuplename} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\tupleexp{\cdot,\ldots}}
    \` \ruleref{\rulechecklooptuplename} \\
  \ruleispending{\Sigma}{\Gamma}{\tupleexp{\cdot,\ldots}}{\tau_1}{\tuple{\tau_1,\ldots}}{\tau''}
    \` \ruleref{\ruleispendingtuplename} \\
  \rulecheckframetype{\Sigma}{A}{\pushtuplestack}{\tau_1}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  \rulegetframecontext{\Sigma}{\pushtuplestack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulegetframeassigned{\pushtuplestack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulegetloopcontext{\pushtuplestack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \ruledirok{\rhd}{e_1}
    \` \ruleref{\ruledirokpushingname} \\
  $\tau_1 \not= \commandty$
    \` No possible derivation of \ruletausmall{\commandty} \\
  \impliescmdreturn{\tau_1}{\Sigma}{\Gamma}{e_1}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\pushtuplestack}}{\tau}{\rhd}{e_1}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}


\item[\rulestepnexttupleelem] \ \\
  \newcommand{\nexttuplestackpre}{\frameexp{F}{\tupleexp{\ldots,\cdot,e_i,\ldots}}}
  \newcommand{\nexttuplestack}{\frameexp{F}{\tupleexp{\ldots,v,\cdot,\ldots}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{\nexttuplestackpre}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{v}{\tau_{i-1}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\nexttuplestackpre}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulegetloopcontext{\nexttuplestackpre}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulecheckloop{L}{v}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestackpre}}{\tau}{\lhd}{v} \\
  \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{\ldots,\cdot,e_i,\ldots}}{A}
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \rulecheckloop{L}{\tupleexp{\ldots, \cdot, e_i, \ldots}}
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''}
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \ldots{} \rulecheckassign{\Gamma}{A}{\cdot}{A} \rulecheckassign{\Gamma}{A}{e_i}{A} \ldots
    \` Inversion on \rulecheckassign{\Gamma}{A}{\tupleexp{\ldots,\cdot,e_i,\ldots}}{A} \\
  \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot,e_i,\ldots}}{\tau_{i-1}}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
    \` Inversion \rulecheckframetype{\Sigma}{A}{\nexttuplestackpre}{\tau_{i-1}}{\tau''} \\
  \ldots{} \rulecheckexp{\Sigma}{\Gamma}{e_i}{\tau_i} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot,e_i,\ldots}}{\tau_{i-1}}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
  \ruletausmall{\tau_1} \ldots \ruletausmall{\tau_n} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot,e_i,\ldots}}{\tau_{i-1}}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
  \ldots{} \rulecheckloop{L}{\cdot} \rulecheckloop{L}{e_i} \ldots
    \` Inversion on \rulecheckloop{L}{\tupleexp{\ldots, \cdot, e_i, \ldots}} \\
  \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{\ldots,v,\cdot,\ldots}}{A}
    \` \ruleref{\rulecheckassigntuplename} \\
  \rulecheckloop{L}{\tupleexp{\ldots,v,\cdot,\ldots}}
    \` \ruleref{\rulechecklooptuplename} \\
  \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,v,\cdot,\ldots}}{\tau_i}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''}
    \` \ruleref{\ruleispendingtuplename} \\
  \rulecheckframetype{\Sigma}{A}{\nexttuplestack}{\tau_i}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  \rulegetframecontext{\Sigma}{\nexttuplestack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulegetframeassigned{\nexttuplestack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulegetloopcontext{\nexttuplestack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \ruledirok{\rhd}{e_i}
    \` \ruleref{\ruledirokpushingname} \\
  $\tau_i \not= \commandty$
    \` No possible derivation of \ruletausmall{\commandty} \\
  \impliescmdreturn{\tau_i}{\Sigma}{\Gamma}{e_i}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\nexttuplestack}}{\tau}{\rhd}{e_i}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteplasttupleelem] \ \\
  \newcommand{\lasttuplestack}{\frameexp{F}{\tupleexp{\ldots,\cdot}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{\lasttuplestack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{v}{\tau_n}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\lasttuplestack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{v}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulegetloopcontext{\lasttuplestack}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulecheckloop{L}{v}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\lasttuplestack}}{\tau}{\lhd}{v} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulegetframecontext{\Sigma}{\lasttuplestack}{\Gamma} \\
  \rulecheckassign{\Gamma}{A}{\tupleexp{\ldots,\cdot}}{A}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''} \\
  \rulecheckloop{L}{\tupleexp{\ldots,\cdot}}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''} \\
  \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot}}{\tau_n}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{F}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\lasttuplestack}{\tau_n}{\tau''} \\
  \\
  \ruletausmall{\tau_1} \ldots \ruletausmall{\tau_n} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot}}{\tau_n}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
  $\ldots = { v_i }$ where \rulecheckval{\Sigma}{v_i}{\tau_i} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\tupleexp{\ldots,\cdot}}{\tau_n}{\tuple{\tau_1,\ldots,\tau_n}}{\tau''} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\lasttuplestack}{A} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulegetloopcontext{\lasttuplestack}{L} \\
  \ldots \rulecheckexp{\Sigma}{\Gamma}{v_i}{\tau_i} \ldots
    \` \ruleref{\rulecheckexpvaluename} \\
  \rulecheckexp{\Sigma}{\Gamma}{\tupleexp{\ldots,v}}{\tuple{\tau_1,\ldots,\tau_n}}
    \` \ruleref{\rulecheckexptuplename} \\
  \ldots \rulecheckloop{L}{v_i} \ldots
    \` \ruleref{\rulecheckloopvaluename} \\
  \rulecheckloop{L}{\tupleexp{\ldots,v}}
    \` \ruleref{\rulechecklooptuplename} \\
  \ruledirok{\lhd}{\tuple{\ldots,v}}
    \` \ruleref{\rulediroktuplename} \\
  \impliescmdreturn{\tuple{\tau_1,\ldots,\tau_n}}{\Sigma}{\Gamma}{\tuple{\ldots,v}}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\tuple{\ldots,v}}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulestepalloc] \ \\
  Note: some trivial steps omitted here.
  \begin{tabbing}
  % Show type
  \rulecheckexp{\Sigma}{\Gamma}{\allocexp{\tau_a}}{\pointer{\tau}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \\
  % Show can alloc
  \rulecanalloc{\tau_a}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\allocexp{\tau_a}}{\pointer{\tau}} \\
  % Apply lemma
  $\exists \mu' . \ruleallocval{\mu}{a}{\tau_a}{\mu'}$ and $\mu' : \Sigma'$ and $\Sigma \le \Sigma'$ and $\Sigma'(a) = \tau_a$.
    \` Lemma \ref{allocprogress} \\
  % Show stack is well formed in new memory signature
  \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \` Lemma \ref{allocsafety} \\
  % Extract new gamma
  \rulegetframecontext{\Sigma'}{F}{\Gamma'} \`
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \\
  % Extract assign changes
  \rulecheckassign{\Gamma}{A}{\allocexp{\tau_a}}{A}
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \\
  % Extract well typed stack
  \rulecheckframetype{\Sigma'}{A}{F}{\pointer{\tau_a}}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \\
  % extract rest of stack
  \rulecheckstack{\Sigma'}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\rhd}{\allocexp{\tau_a}} \\
  % Show loop
  \rulecheckloop{L}{\address{a}} \` \ruleref{\rulecheckloopvaluename} \\
  % Show assign changes
  \rulecheckassign{\Gamma}{A}{\address{a}}{A} \` \ruleref{\rulecheckassignvaluename} \\
  % Show dir ok
  \ruledirok{\lhd}{\address{a}} \` \ruleref{\ruledirokreturningname} \\
  % Show value is well typed
  \rulecheckval{\Sigma'}{\address{a}}{\pointer{\tau_a}} \` \ruleref{\rulecheckvaladdressname} \\
  % Show value is well typed as exp
  \rulecheckexp{\Sigma'}{\Gamma'}{\address{a}}{\pointer{\tau_a}} \` \ruleref{\rulecheckexpvaluename} \\
  % Show the return safety
  \impliescmdreturn{\pointer{\tau_a}}{\Sigma}{\Gamma}{\address{a}}{\tau''}
    \` Vacuously true \\
  % done!
  \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\lhd}{\address{a}} \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppushallocarray] \ \\
  \newcommand{\pushallocarraystack}{\frameexp{F}{\allocarrayexp{\tau_a}{\cdot}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\allocarrayexp{\tau_a}{e}}{\arraytype{\tau_a}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulecheckassign{\Gamma}{A}{\allocarrayexp{\tau_a}{e}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\arraytype{\tau_a}}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \rulecheckloop{L}{\allocarrayexp{\tau_a}{e}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\allocarrayexp{\tau_a}{e}} \\
  \\
  \rulecheckexp{\Sigma}{\Gamma}{e}{\integer} and \rulecanalloc{\tau_a}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\allocarrayexp{\tau_a}{e}}{\arraytype{\tau}} \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\allocarrayexp{\tau_a}{\cdot}}{A}
    \` \ruleref{\rulecheckassignallocarrayname} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\allocarrayexp{\tau_a}{\cdot}}
    \` \ruleref{\rulecheckloopallocarrayname} \\
  \ruleispending{\Sigma}{\Gamma}{\allocarrayexp{\tau_a}{\cdot}}{\integer}{\bool}{\tau''}
    \` \ruleref{\ruleispendingallocarrayname} \\
  \rulecheckframetype{\Sigma}{A}{\pushallocarraystack}{\integer}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  \rulegetframecontext{\Sigma}{\pushallocarraystack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulegetframeassigned{\pushallocarraystack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulecheckassign{\Gamma}{A}{e}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\allocarrayexp{\tau_a}{e}}{A} \\
  \rulecheckloop{L}{e}
    \` Inversion on \rulecheckloop{L}{\allocarrayexp{\tau_a}{e}} \\
  \rulegetloopcontext{\pushallocarraystack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \ruledirok{\rhd}{e}
    \` \ruleref{\ruledirokpushingname} \\
  \impliescmdreturn{\integer}{\Sigma}{\Gamma}{e}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\pushallocarraystack}}{\tau}{\rhd}{e}
    \` \ruleref{\rulecheckstatenormalname} \\
 \end{tabbing}

\item[\rulesteppopallocarray] \ \\
  \begin{tabbing}
  \rulegetframeassigned{\pushallocarraystack}{A} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckassign{\Gamma}{A}{\intliteral{n}}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \ruleispending{\Sigma}{\Gamma}{\allocarrayexp{\tau_a}{\cdot}}{\integer}{\arraytype{\tau_a}}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \rulecanalloc{\tau_a}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \\
  $\exists \Sigma'.\mu' : \Sigma'$ and $\Sigma \le \Sigma'$ and \rulecheckval{\Sigma'}{\arrayval{a}{n}}{\arraytype{\tau_a}}
    \` Lemma \ref{allocarraypres} \\
  \rulecheckstate{\Sigma'}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}}
    \` Lemma \ref{allocsafety} \\
  \rulegetframeassigned{\pushallocarraystack}{A} \\
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckassign{\Gamma}{A}{\intliteral{n}}{A}
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\arraytype{\tau_a}} \\
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \rulecheckstack{\Sigma'}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma'}{\stackframe{K}{\pushallocarraystack}}{\tau}{\lhd}{\intliteral{n}} \\
  \\
  \rulegetframecontext{\Sigma'}{F}{\Gamma}
    \` Inversion on \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{\allocarrayexp{\tau_a}{\cdot}}{A}
    \` Inversion on \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \ruleispending{\Sigma'}{\Gamma}{\allocarrayexp{\tau_a}{\cdot}}{\integer}{\arraytype{\tau_a}}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \rulecheckframetype{\Sigma'}{\Gamma}{F}{\arraytype{\tau_a}}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma'}{A}{\pushallocarraystack}{\integer}{\tau''} \\
  \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\pushallocarraystack}{A} \\
  \rulecheckloop{L}{\arrayval{a}{n}}
    \` \ruleref{\rulecheckloopvaluename} \\
  \rulecheckassign{\Gamma}{A}{\arrayval{a}{n}}{A}
    \` \ruleref{\rulecheckassignvaluename} \\
  \ruledirok{\lhd}{\arrayval{a}{n}}
    \` \ruleref{\ruledirokreturningname} \\
  \impliescmdreturn{\arraytype{\tau_a}}{\Sigma'}{\Gamma}{\arrayval{a}{n}}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma'}{\stackframe{K}{F}}{\tau}{\lhd}{\arrayval{a}{n}}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteppopallocarrayerr] \ \\
  \begin{tabbing}
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\exn{}}
    \` \ruleref{\rulecheckstateexnname} \\
  \end{tabbing}

\item[\rulesteppushif] \ \\
  \newcommand{\ifstack}{\frameexp{F}{\ifexp{\cdot}{e_t}{e_f}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \rulecheckassign{\Gamma}{A}{\ifexp{e_c}{e_t}{e_f}}{A'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \\
  \rulecheckexp{\Sigma}{\Gamma}{e_c}{\bool} and \rulecheckexp{\Sigma}{\Gamma}{e_t}{\tau'} and \rulecheckexp{\Sigma}{\Gamma}{e_f}{\tau'} \\
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau'} \\
  \rulecheckassign{\Gamma}{A}{e_c}{A} and \rulecheckassign{\Gamma}{A}{e_t}{A_t} and \rulecheckassign{\Gamma}{A}{e_f}{A_f} where $A_t \cap A_f = A'$ \\
    \` Inversion on \rulecheckassign{\Gamma}{A}{\ifexp{e_c}{e_t}{e_f}}{A'} \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\ifexp{\cdot}{e_t}{e_f}}{A'}
    \` \ruleref{\rulecheckassignifname} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \rulecheckloop{L}{\ifexp{e_c}{e_t}{e_f}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  \\
  There are two possible rules used for the derivation of
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
  Case \rulefmt{\rulecheckstatenormalname} \+ \\
    \rulecheckframetype{\Sigma}{A'}{F}{\tau'}{\tau''}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
    \impliescmdreturn{\tau'}{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
    \rulecheckloop{L}{e_t} and \rulecheckloop{L}{e_f} and \rulecheckloop{L}{e_c}
      \` Inversion on \rulecheckloop{L}{\ifexp{e_c}{e_t}{e_f}} \\
    \rulecheckloop{L}{\cdot}
      \` \ruleref{\rulecheckloopvarname} \\
    \rulecheckloop{L}{\ifexp{\cdot}{e_t}{e_f}}
      \` \ruleref{\rulecheckloopifname} \\
    \impliescmdreturnsimple{e_t} and \impliescmdreturnsimple{e_f} \\
      \` Inversion on \impliescmdreturn{\tau'}{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
    \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''}
      \` \ruleref{\ruleispendingifname} \\
    \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpnoretname} \- \\
  Otherwise \rulefmt{\rulecheckstatereturnsname} was used: \+ \\
    \rulereturns{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
    $L = \notinloop$
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
    $\tau' = \commandty$
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\ifexp{e_c}{e_t}{e_f}} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{e_t}{\tau''} and \ruleonlyreturns{\Sigma}{\Gamma}{e_f}{\tau''} \\
      \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
    \ruledoesreturn{\ifexp{e_c}{e_t}{e_f}}
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\ifexp{e_c}{e_t}{e_f}}{\tau''} \\
    \ruledoesreturn{e_t} and \ruledoesreturn{e_f}
      \` Inversion on \ruledoesreturn{\ifexp{e_c}{e_t}{e_f}} \\
    \ruledoesreturn{\ifexp{\cdot}{e_t}{e_f}}
      \` \ruleref{\ruledoesreturnifname} \\
    \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\commandty}{\tau''}
      \` \ruleref{\ruleispendingifname} \\
    \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpretname} \- \\
  \rulegetframecontext{\Sigma}{\ifstack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulegetframeassigned{\ifstack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulegetloopcontext{\ifstack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \rulecheckloop{L}{e_c}
    \` Inversion on \rulecheckloop{L}{\ifexp{e_c}{e_t}{e_f}} \\
  \ruledirok{\rhd}{e_c}
    \` \ruleref{\ruledirokpushingname} \\
  \impliescmdreturn{\bool}{\Sigma}{\Gamma}{e_c}{\tau''}
    \` Vacuously true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\rhd}{e_c}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteppopiftrue] \ \\
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{\ifstack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{\true}{\bool}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\ifstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{\true}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulegetframecontext{\Sigma}{\ifstack}{\Gamma} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\ifstack}{A} \\
  \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  \rulecheckexp{\Sigma}{\Gamma}{e_t}{\tau'}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
  \impliescmdreturn{\tau'}{\Sigma}{\Gamma}{e_t}{\tau''} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{\ifexp{\cdot}{e_t}{e_f}}{A'}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{e_t}{A_t} and \rulecheckassign{\Gamma}{A}{e_f}{A_f} where $A_t \cap A_f = A'$ \\
    \` Inversion on \rulecheckassign{\Gamma}{A}{\ifexp{\cdot}{e_t}{e_f}}{A'} \\
  There are two possible rules used for the derivation of \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  Case \rulefmt{\rulecheckframetypeframeexpnoretname} \+ \\
    \rulegetloopcontext{F}{L}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckloop{L}{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckframetype{\Sigma}{A'}{F}{\tau'}{\tau''}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckframetype{\Sigma}{A_t}{F}{\tau'}{\tau''}
      \` Lemma \ref{extendAframetype} \\
    \rulecheckloop{L}{e_t}
      \` Inversion on \rulecheckloop{L}{\ifexp{\cdot}{e_t}{e_f}} \\
    \ruledirok{\rhd}{e_t}
      \` \ruleref{\ruledirokpushingname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{e_t}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise \rulefmt{\rulecheckframetypeframeexpretname} \+ \\
    \rulegetloopcontext{F}{\notinloop}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckloop{\notinloop}{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \ruledoesreturn{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    $\tau' = \commandty$
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \ruledoesreturn{e_t}
      \` Inversion on \ruledoesreturn{\ifexp{\cdot}{e_t}{e_f}} \\
    \rulereturns{\Sigma}{\Gamma}{e_t}{\tau''}
      \` \ruleref{\rulereturnsonlyname} \\
    \rulecheckloop{\notinloop}{e_t}
      \` Inversion on \rulecheckloop{\notinloop}{\ifexp{\cdot}{e_t}{e_f}} \\
    \ruledirok{\rhd}{e_t}
      \` \ruleref{\ruledirokpushingname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{e_t}
      \` \ruleref{\rulecheckstatereturnsname} \\

  \end{tabbing}

\item[\rulesteppopiffalse] \ \\
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{\ifstack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckexp{\Sigma}{\Gamma}{\false}{\bool}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulegetframeassigned{\ifstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckassign{\Gamma}{A}{\false}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\ifstack}}{\tau}{\lhd}{v} \\
  \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulegetframecontext{\Sigma}{\ifstack}{\Gamma} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\ifstack}{A} \\
  \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  \rulecheckexp{\Sigma}{\Gamma}{e_f}{\tau'}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
  \impliescmdreturn{\tau'}{\Sigma}{\Gamma}{e_f}{\tau''} \\
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\ifexp{\cdot}{e_t}{e_f}}{\bool}{\tau'}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{\ifexp{\cdot}{e_t}{e_f}}{A'}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  \rulecheckassign{\Gamma}{A}{e_t}{A_t} and \rulecheckassign{\Gamma}{A}{e_f}{A_f} where $A_t \cap A_f = A'$ \\
    \` Inversion on \rulecheckassign{\Gamma}{A}{\ifexp{\cdot}{e_t}{e_f}}{A'} \\
  There are two possible rules used for the derivation of \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
  Case \rulefmt{\rulecheckframetypeframeexpnoretname} \+ \\
    \rulegetloopcontext{F}{L}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckloop{L}{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckframetype{\Sigma}{A'}{F}{\tau'}{\tau''}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckframetype{\Sigma}{A_f}{F}{\tau'}{\tau''}
      \` Lemma \ref{extendAframetype} \\
    \rulecheckloop{L}{e_f}
      \` Inversion on \rulecheckloop{L}{\ifexp{\cdot}{e_t}{e_f}} \\
    \ruledirok{\rhd}{e_f}
      \` \ruleref{\ruledirokpushingname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{e_f}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise \rulefmt{\rulecheckframetypeframeexpretname} \+ \\
    \rulegetloopcontext{F}{\notinloop}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \rulecheckloop{\notinloop}{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \ruledoesreturn{\ifexp{\cdot}{e_t}{e_f}}
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    $\tau' = \commandty$
      \` Inversion on \rulecheckframetype{\Sigma}{A}{\ifstack}{\bool}{\tau''} \\
    \ruledoesreturn{e_f}
      \` Inversion on \ruledoesreturn{\ifexp{\cdot}{e_t}{e_f}} \\
    \rulereturns{\Sigma}{\Gamma}{e_f}{\tau''}
      \` \ruleref{\rulereturnsonlyname} \\
    \rulecheckloop{\notinloop}{e_f}
      \` Inversion on \rulecheckloop{\notinloop}{\ifexp{\cdot}{e_t}{e_f}} \\
    \ruledirok{\rhd}{e_f}
      \` \ruleref{\ruledirokpushingname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{e_f}
      \` \ruleref{\rulecheckstatereturnsname} \\

  \end{tabbing}

\item[\rulesteppushdecl] \ \\
  \newcommand{\pushdeclstack}{\framevar{F}{x}{\tau_x}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\decl{x}{\tau_x}{e}}{\commandty}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  \rulecheckassign{\Gamma}{A}{\decl{x}{\tau_x}{e}}{A' - \{x\}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  $x \not\in A$ and \rulecheckassign{\varctx{\Gamma}{x}{\tau_x}}{A}{e}{A'}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\decl{x}{\tau}{e}}{A' - \{x\}} \\
  \rulecheckexp{\Sigma}{\varctx{\Gamma}{x}{\tau_x}}{e}{\commandty}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\decl{x}{\tau_x}{e}}{\commandty} \\
  There are two possible rules used for the derivation of
     \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
  Case \rulefmt{\rulecheckstatenormalname}: \+ \\
    \rulecheckframetype{\Sigma}{A' - \{x\}}{F}{\commandty}{\tau''}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \rulegetloopcontext{F}{L}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \rulecheckloop{L}{\decl{x}{\tau_x}{e}}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\decl{x}{\tau}{e}}{\tau''} \\
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \rulecheckframetype{\Sigma}{A'}{\pushdeclstack}{\commandty}{\tau''}
      \` \ruleref{\rulecheckframetypeframevarname} \\
    \rulegetframecontext{\Sigma}{\pushdeclstack}{\varctx{\Gamma}{x}{\tau_x}}
      \` \ruleref{\rulegetframecontextvarname} \\
    \rulegetframeassigned{\pushdeclstack}{A}
      \` \ruleref{\rulegetframeassignedvarname} \\
    \rulegetloopcontext{\pushdeclstack}{L}
      \` \ruleref{\rulegetloopcontextdeclname} \\
    \rulecheckloop{L}{e}
      \` Inversion on \rulecheckloop{L}{\decl{x}{\tau_x}{e}} \\
    \ruledirok{\rhd}{e}
      \` \ruleref{\ruledirokpushingname} \\
    \ruleonlyreturns{\Sigma}{\varctx{\Gamma}{x}{\tau_x}}{e}{\tau''}
      \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\decl{x}{\tau_x}{e}}{\tau''} \\
    \impliescmdreturn{\commandty}{\Sigma}{\varctx{\Gamma}{x}{\tau_x}}{e}{\tau''}
      \` Weakening \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\pushdeclstack}}{\tau}{\rhd}{e}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise \rulefmt{\rulecheckstatereturnsname} was used: \+ \\
    \rulegetloopcontext{F}{\notinloop}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \rulecheckloop{\notinloop}{\decl{x}{\tau_x}{e}}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \rulereturns{\Sigma}{\Gamma}{\decl{x}{\tau}{e}}{\tau''}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\decl{x}{\tau_x}{e}} \\
    \ruledoesreturn{\decl{x}{\tau_x}{e}}
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\decl{x}{\tau}{e}}{\tau''} \\
    \ruledoesreturn{e}
      \` Inversion on \ruledoesreturn{\decl{x}{\tau_x}{e}} \\
    \ruletausmall{\tau''}
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\decl{x}{\tau}{e}}{\tau''} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{\decl{x}{\tau_x}{e}}{\tau''} \\
      \` Inversion on \rulereturns{\Sigma}{\Gamma}{\decl{x}{\tau}{e}}{\tau''} \\
    \ruleonlyreturns{\Sigma}{\varctx{\Gamma}{x}{\tau_x}}{e}{\tau''}
      \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\decl{x}{\tau_x}{e}}{\tau''} \\
    \rulereturns{\Sigma}{\varctx{\Gamma}{x}{\tau_x}}{e}{\tau''}
      \` \ruleref{\rulereturnsonlyname} \\
    \rulegetloopcontext{\pushdeclstack}{\notinloop}
      \` \ruleref{\rulegetloopcontextdeclname} \\
    \rulecheckloop{\notinloop}{e}
      \` Inversion on \rulecheckloop{\notinloop}{\decl{x}{\tau_x}{e}} \\
    \ruledirok{\rhd}{e}
      \` \ruleref{\ruledirokpushingname} \\
    \rulegetframecontext{\Sigma}{\pushdeclstack}{\varctx{\Gamma}{x}{\tau_x}}
      \` \ruleref{\rulegetframecontextvarname} \\
    \rulegetframeassigned{\pushdeclstack}{A}
      \` \ruleref{\rulegetframeassignedvarname} \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\pushdeclstack}}{\tau}{\rhd}{e}
      \` \ruleref{\rulecheckstatereturnsname} \\
  \end{tabbing}

\item[\rulesteppopdecl] \ \\
  \newcommand{\popdeclstack}{\framevar{F}{x}{\tau_x}}
  \begin{tabbing}
  \rulegetframeassigned{\popdeclstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popdeclstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckassign{\Gamma}{A}{\nop}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popdeclstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckframetype{\Sigma}{A}{\popdeclstack}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popdeclstack}}{\tau}{\lhd}{\nop} \\
  \rulegetloopcontext{\popdeclstack}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popdeclstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popdeclstack}}{\tau}{\lhd}{\nop} \\
  \rulegetframeassigned{F}{A} and $x \not\in A$
    \` Inversion on \rulegetframeassigned{\popdeclstack}{A} \\
  \rulecheckframetype{\Sigma}{A - \{x\}}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popdeclstack}{\commandty}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` $x \not\in A \Rightarrow A - \{x\} = A$ \\
  \rulegetframecontext{\Sigma}{F}{\Gamma} for some $\Gamma$
    \` By construction \\
  \rulecheckvalnopconclusion{}
    \` \ruleref{\rulecheckvalnopname} \\
  \rulecheckexp{\Sigma}{\Gamma}{\nop}{\commandty}
    \` \ruleref{\rulecheckexpvaluename} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulegetloopcontext{\popdeclstack}{L} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{\nop}{\tau''}
    \` \ruleref{\ruleonlyreturnsnopname} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\nop}{\tau''}
    \` Weakening \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\nop}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppushassign] \ \\
  \newcommand{\pushassignstack}{\frameexp{F}{\assign{x}{\cdot}}}
  \begin{tabbing}
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\assign{x}{e}}{\commandty}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulecheckassign{\Gamma}{A}{\assign{x}{e}}{A \cup \{x\}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulecheckloop{L}{\assign{x}{e}}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulecheckframetype{\Sigma}{A \cup \{x\}}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\assign{x}{e}} \\
  $\Gamma = \varctx{\Gamma'}{x}{\tau'}$ and \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'} and \ruletausmall{\tau'}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\assign{x}{e}}{\commandty} \\
  \rulecheckassign{\Gamma}{A}{e}{A}
    \` Inversion on \rulecheckassign{\Gamma}{A}{\assign{x}{e}}{A \cup \{x\}} \\
  \rulecheckloop{L}{e}
    \` Inversion on \rulecheckloop{L}{\assign{x}{e}} \\
  \rulecheckassign{\Gamma}{A}{\cdot}{A}
    \` \ruleref{\rulecheckassignholename} \\
  \rulecheckassign{\Gamma}{A}{\assign{x}{\cdot}}{A \cup \{x \}}
    \` \ruleref{\rulecheckassignassignname} \\
  \rulecheckloop{L}{\cdot}
    \` \ruleref{\rulecheckloopvarname} \\
  \rulecheckloop{L}{\assign{x}{\cdot}}
    \` \ruleref{\rulecheckloopassignname} \\
  \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'}
    \` \ruleref{\rulecheckexpvarname} \\
  \ruleispending{\Sigma}{\Gamma}{\assign{x}{\cdot}}{\tau'}{\commandty}{\tau''}
    \` \ruleref{\ruleispendingassignname} \\
  \rulecheckframetype{\Sigma}{A}{\pushassignstack}{\tau'}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\

  \rulegetframecontext{\Sigma}{\pushassignstack}{\Gamma}
    \` \ruleref{\rulegetframecontextexpname} \\
  \rulegetframeassigned{\pushassignstack}{A}
    \` \ruleref{\rulegetframeassignedexpname} \\
  \rulegetloopcontext{\pushassignstack}{L}
    \` \ruleref{\rulegetloopcontextexpname} \\
  \ruledirok{\rhd}{e}
    \` \ruleref{\ruledirokpushingname} \\

  Since \ruletausmall{\tau''} by inversion $\tau'' \not= \commandty$. \\
  \impliescmdreturn{\tau''}{\Sigma}{\Gamma}{e}{\tau''}
    \` Vacuously true \\

  \rulecheckstate{\Sigma}{\stackframe{K}{\pushassignstack}}{\tau}{\rhd}{e}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteppopassign]
  \newcommand{\popassignstackmini}{\frameexp{\frameval{F}{x}{\tau_x}{v}}{\ldots}}
  \newcommand{\popassignstackminipost}{\frameexp{\frameval{F}{x}{\tau_x}{v'}}{\ldots}}
  \newcommand{\popassignstack}{\frameexp{\popassignstackmini}{\assign{x}{\cdot}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{\popassignstack}{\Gamma} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignstack}}{\tau}{\lhd}{v'} \\
  \rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignstack}}{\tau}{\lhd}{v'} \\
  \rulegetframeassigned{\popassignstack}{A} \\
    \` Inversion on \rulecheckstate{\Sigma}{\popassignstack}{\tau}{\lhd}{v'} \\
  \rulecheckassign{\Gamma}{A}{v'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\popassignstack}{\tau}{\lhd}{v'} \\
  \rulecheckframetype{\Sigma}{A}{\popassignstack}{\tau'}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\popassignstack}{\tau}{\lhd}{v'} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\popassignstack}{\tau}{\lhd}{v'} \\
  \ruleispending{\Sigma}{\Gamma}{\assign{x}{\cdot}}{\tau'}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignstack}{\tau'}{\tau''} \\
  \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\assign{x}{\cdot}}{\tau'}{\commandty}{\tau''} \\
  \rulecheckexp{\Sigma}{\varctx{\Gamma'}{x}{\tau'}}{x}{\tau'} where $\Gamma = \varctx{\Gamma'}{x}{\tau'}$
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'} \\
  \rulecheckval{\Sigma}{v'}{\tau'}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'} \\
  \rulecheckval{\Sigma}{v}{\tau'} and $\tau' = \tau_x$
    \` Lemma \ref{stackvarshape} \\
  \rulegetframeassigned{\popassignstackminipost}{A}
    \` Lemma \ref{assignassigned} \\
  \rulecheckframetype{\Sigma}{A}{\popassignstackmini}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignstack}{\tau'}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{\popassignstackminipost}{\commandty}{\tau''}
    \` Lemma \ref{assignframetype} \\
  \rulegetframecontext{\Sigma}{\popassignstackminipost}{\Gamma''} for some $\Gamma''$
    \` By construction \\
  \rulecheckexp{\Sigma}{\Gamma''}{\nop}{\commandty}
    \` \ruleref{\rulecheckexpvaluename} \\
  \rulecheckassign{\Gamma}{A}{\nop}{A}
    \` \ruleref{\rulecheckassignvarname} \\
  \rulegetloopcontext{\popassignstackminipost}{L} for some $L$
    \` By construction \\
  \rulecheckloop{L}{\nop}
    \` \ruleref{\rulecheckloopvaluename} \\
  \ruledirok{\lhd}{\nop}
    \` \ruleref{\ruledirokreturningname} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\nop}{\tau''}
    \` Weakening of \ruleref{\ruleonlyreturnsnopname} \\

  \rulecheckstate{\Sigma}{\stackframe{K}{\popassignstackminipost}}{\tau}{\lhd}{\nop}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppopassignfirst] \ \\
  \newcommand{\popassignfirststackmini}{\frameexp{\framevar{F}{x}{\tau}}{\ldots}}
  \newcommand{\popassignfirststackminipost}{\frameexp{\frameval{F}{x}{\tau}{v'}}{\ldots}}
  \newcommand{\popassignfirststack}{\frameexp{\popassignfirststackmini}{\assign{x}{\cdot}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulegetframecontext{\Sigma}{\popassignfirststack}{\Gamma} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignfirststack}}{\tau}{\lhd}{v'} \\
  \rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignfirststack}}{\tau}{\lhd}{v'} \\
  \rulegetframeassigned{\popassignfirststack}{A} \\
    \` Inversion on \rulecheckstate{\Sigma}{\popassignfirststack}{\tau}{\lhd}{v'} \\
  \rulecheckassign{\Gamma}{A}{v'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\popassignfirststack}{\tau}{\lhd}{v'} \\
  \rulecheckframetype{\Sigma}{A}{\popassignfirststack}{\tau'}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\popassignfirststack}{\tau}{\lhd}{v'} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\popassignstack}{\tau}{\lhd}{v'} \\
  \ruleispending{\Sigma}{\Gamma}{\assign{x}{\cdot}}{\tau'}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignfirststack}{\tau'}{\tau''} \\
  \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\assign{x}{\cdot}}{\tau'}{\commandty}{\tau''} \\
  \rulecheckexp{\Sigma}{\varctx{\Gamma'}{x}{\tau'}}{x}{\tau'} where $\Gamma = \varctx{\Gamma'}{x}{\tau'}$
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{x}{\tau'} \\
  \rulecheckval{\Sigma}{v'}{\tau'}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{v'}{\tau'} \\
  \rulecheckval{\Sigma}{v'}{\tau_x}
    \` Lemma \ref{stackvarshape} \\
  \rulegetframeassigned{\popassignfirststackminipost}{A \cup \{x\}}
    \` Lemma \ref{assignfirstassigned} \\
  \rulecheckframetype{\Sigma}{A \cup \{x\}}{\popassignfirststackmini}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignfirststack}{\tau'}{\tau''} \\
  \rulecheckframetype{\Sigma}{A \cup \{x\}}{\popassignfirststackminipost}{\commandty}{\tau''}
    \` Lemma \ref{assignfirstframetype} \\
  \rulegetframecontext{\Sigma}{\popassignfirststackminipost}{\Gamma''} for some $\Gamma''$
    \` By construction \\
  \rulecheckexp{\Sigma}{\Gamma''}{\nop}{\commandty}
    \` \ruleref{\rulecheckexpvaluename} \\
  \rulecheckassign{\Gamma}{A \cup \{x\}}{\nop}{A \cup \{x\}}
    \` \ruleref{\rulecheckassignvarname} \\
  \rulegetloopcontext{\popassignfirststackminipost}{L} for some $L$
    \` By construction \\
  \rulecheckloop{L}{\nop}
    \` \ruleref{\rulecheckloopvaluename} \\
  \ruledirok{\lhd}{\nop}
    \` \ruleref{\ruledirokreturningname} \\

  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\nop}{\tau''}
    \` Weakening of \ruleref{\ruleonlyreturnsnopname} \\

  \rulecheckstate{\Sigma}{\stackframe{K}{\popassignfirststackminipost}}{\tau}{\lhd}{\nop}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteppopassigned] \ \\
  \newcommand{\popassignedstack}{\frameval{F}{x}{\tau_x}{v}}
  \begin{tabbing}
  \rulegetframeassigned{\popassignedstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignedstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckassign{\Gamma}{A}{\nop}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignedstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\popassignedstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckframetype{\Sigma}{A - \{x\}}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\
  \rulegetframeassigned{F}{A'} where $A' \cup \{x\} = A$ and $x \not\in A'$ \\
    \` Inversion on \rulegetframeassigned{\popassignedstack}{A} \\
  $A - \{x\} = A'$
    \` $A' \cup \{x\} = A$ and $x \not\in A$ \\
  \rulecheckassign{\Gamma}{A'}{\nop}{A'}
    \` \ruleref{\rulecheckassignvaluename} \\

  \rulegetframecontext{\Sigma}{\popassignedstack}{\Gamma}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulegetframecontext{\Sigma}{\popassignedstack}{\Gamma} \\

  \rulecheckvalnopconclusion{}
    \` \ruleref{\rulecheckvalnopname} \\
  \rulecheckexp{\Sigma}{\Gamma}{\nop}{\commandty}
    \` \ruleref{\rulecheckexpvaluename} \\

  \rulegetloopcontext{\popassignedstack}{L}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulegetloopcontext{\popassignedstack}{L} \\

  \rulecheckloop{L}{\nop}
    \` \ruleref{\rulecheckloopvaluename} \\

  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\

  \ruledirok{\lhd}{\nop}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\

  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\nop}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\popassignedstack}{\commandty}{\tau''} \\

  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\nop}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteppushret] \ \\
  \newcommand{\pushretstack}{\frameexp{F}{\return{\cdot}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \kill
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\return{e}}{\commandty}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  \rulecheckassignreturnconclusion{} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  There are two possible rules used for the derivation of
    \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
  Case \rulefmt{\rulecheckstatenormalname}: \+ \\
    \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
    \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\return{e}}{\tau''} \\
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
    \ruleonlyreturns{\Sigma}{\Gamma}{\return{e}}{\tau''}
      \` Modus ponens \\
    \rulecheckexp{\Sigma}{\Gamma}{e}{\tau''} and \ruletausmall{\tau''}
      \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\return{e}}{\tau''} \\
    \rulegetloopcontext{F}{L}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
    \rulecheckloop{L}{\return{e}}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
    % Now start constructing the stack
    \ruledoesreturn{\return{\cdot}}
      \` \ruleref{\ruledoesreturnreturnname} \\
    \rulecheckassign{\Gamma}{A}{\cdot}{A}
      \` \ruleref{\rulecheckassignholename} \\
    \rulecheckassign{\Gamma}{A}{\return{\cdot}}{A}
      \` \ruleref{\rulecheckassignreturnname} \\
    \rulecheckloop{L}{\return{\cdot}}
      \` \ruleref{\rulecheckloopreturnname} \\
    \ruleispending{\Sigma}{\Gamma}{\return{\cdot}}{\tau''}{\commandty}{\tau''}
      \` \ruleref{\ruleispendingreturnname} \\
    \rulecheckframetype{\Sigma}{A}{\pushretstack}{\tau''}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
    % Now show safe w/top
    \rulegetframecontext{\Sigma}{\pushretstack}{\Gamma}
      \` \ruleref{\rulegetframecontextexpname} \\
    \rulegetframeassigned{\pushretstack}{A}
      \` \ruleref{\rulegetframeassignedexpname} \\
    \rulecheckassign{\Gamma}{A}{e}{A}
      \` Inversion on \rulecheckassign{\Gamma}{A}{\return{e}}{A} \\
    \rulegetloopcontext{\pushretstack}{L}
      \` \ruleref{\rulegetloopcontextexpname} \\
    \rulecheckloop{L}{e}
      \` Inversion on \rulecheckloop{L}{\return{e}} \\
    \ruledirok{\rhd}{e}
      \` \ruleref{\ruledirokpushingname} \\
    Since \ruletausmall{\tau''} by inversion $\tau'' \not= \commandty$. \\
    \impliescmdreturn{\tau''}{\Sigma}{\Gamma}{e}{\tau''}
      \` Vacuously true \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\pushretstack}}{\tau}{\rhd}{e}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  Otherwise \rulefmt{\rulecheckstatereturnsname} \+ was used \\
    \rulegetloopcontext{F}{\notinloop}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\
    \rulecheckloop{\notinloop}{\return{e}}
      \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\return{e}} \\

    \rulecheckexp{\Sigma}{\Gamma}{e}{\tau''}
      \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{e}{\tau''} \\
    \ruledoesreturn{\return{\cdot}}
      \` \ruleref{\ruledoesreturnreturnname} \\

    \rulecheckassign{\Gamma}{A}{\cdot}{A}
      \` \ruleref{\rulecheckassignholename} \\
    \rulecheckassign{\Gamma}{A}{\return{\cdot}}{A}
      \` \ruleref{\rulecheckassignreturnname} \\
    \rulecheckloop{\notinloop}{\return{\cdot}}
      \` \ruleref{\rulecheckloopreturnname} \\
    \ruleispending{\Sigma}{\Gamma}{\return{\cdot}}{\tau''}{\commandty}{\tau''}
      \` \ruleref{\ruleispendingreturnname} \\
    \rulecheckframetype{\Sigma}{A}{\pushretstack}{\tau''}{\tau''}
      \` \ruleref{\rulecheckframetypeframeexpretname} \\

    \rulegetframecontext{\Sigma}{\pushretstack}{\Gamma}
      \` \ruleref{\rulegetframecontextexpname} \\
    \rulegetframeassigned{\pushretstack}{A}
      \` \ruleref{\rulegetframeassignedexpname} \\
    \rulecheckassign{\Gamma}{A}{e}{A}
      \` Inversion on \rulecheckassign{\Gamma}{A}{\return{e}}{A} \\
    \rulegetloopcontext{\pushretstack}{\notinloop}
      \` \ruleref{\rulegetloopcontextexpname} \\
    \rulecheckloop{\notinloop}{e}
      \` Inversion on \rulecheckloop{\notinloop}{\return{e}} \\
    \ruledirok{\rhd}{e}
      \` \ruleref{\ruledirokpushingname} \\
    Since \ruletausmall{\tau''} by inversion $\tau'' \not= \commandty$. \\
    \impliescmdreturn{\tau''}{\Sigma}{\Gamma}{e}{\tau''}
      \` Vacuously true \\
    \rulecheckstate{\Sigma}{\stackframe{K}{\pushretstack}}{\tau}{\rhd}{e}
      \` \ruleref{\rulecheckstatenormalname} \- \\
  \end{tabbing}

\item[\rulesteppopret]
  \newcommand{\retstack}{\stackframe{K}{\frameexp{F}{\return{\cdot}}}}
  \begin{tabbing}
  \hspace{3em} \= \hspace{3em} \= \\
  \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\retstack}{\tau}{\lhd}{e}\\
  \rulecheckframetype{\Sigma}{A}{\retstack}{\tau'}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\retstack}{\tau}{\lhd}{e}\\
  \ruledirok{\lhd}{e}
    \` Inversion on \rulecheckstate{\Sigma}{\retstack}{\tau}{\lhd}{e}\\
  \ruleispending{\Sigma}{\Gamma}{\return{\cdot}}{\tau'}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\retstack}{\tau'}{\tau''} \\
  $\tau' = \tau''$ and \ruletausmall{\tau''}
    \` Inversion on \ruleispending{\Sigma}{\Gamma}{\return{\cdot}}{\tau'}{\commandty}{\tau''} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'} \\
  Case analysis on the derivation of \rulecheckstack{\Sigma}{K}{\tau''}{\tau} gives two possible cases. \\
  If the rule {\tt \rulecheckstackemptyname} was used then \+ \\
    $K = \emptystack{}$ and $\tau = \tau''$
      \` Inversion on \rulecheckstack{\Sigma}{K}{\tau''}{\tau} \\
    Via case analysis on \ruledirok{\lhd}{e}: either $e = $ some $v$ or $e = \tupleexp{}$. \\
    If $e = v$ then \+ \\
      \rulecheckexp{\Sigma}{\cdot}{v}{\tau}
        \` \ruleref{\rulecheckexpvaluename} \- \\
    Otherwise $e = \tupleexp{}$ \+ \\
      $\tau' = \tupleexp{}$
        \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'} \\
      \rulecheckexp{\Sigma}{\cdot}{\tupleexp{}}{\tau}
        \` \ruleref{\rulecheckexptuplename} \- \\
    \rulecheckstateemptyconclusion{}
      \` \ruleref{\rulecheckstateemptyname} \- \\
  Otherwise the rule {\tt \rulecheckstacknonemptyname} was used. \+ \\
    $K = K';F'$ and \rulegetframeassigned{F'}{A'} and \rulecheckframetype{\Sigma}{A'}{F'}{\tau''}{\tau'''} \\
      \hspace{1em} and \rulecheckstack{\Sigma}{K'}{\tau'''}{\tau} 
      \` Inversion on \rulecheckstack{\Sigma}{K}{\tau''}{\tau} \\
    \rulegetframecontext{\Sigma}{F'}{\Gamma'} \` By construction \\
    \rulegetloopcontext{F'}{L} \` By construction \\
    Via case analysis on \ruledirok{\lhd}{e}: either $e = $ some $v$ or $e = \tupleexp{}$. \\
    If $e = v$ then \+ \\
      \rulecheckexp{\Sigma}{\Gamma'}{v}{\tau'}
        \` \ruleref{\rulecheckexpvaluename} \\
      \rulecheckassign{\Gamma}{A'}{v}{A'}
        \` \ruleref{\rulecheckassignvaluename} \\
      \rulecheckloop{L}{v}
        \` \ruleref{\rulecheckloopvaluename} \- \\
    Otherwise $e = \tupleexp{}$ \+ \\
      $\tau' = \tupleexp{}$
        \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{e}{\tau'} \\
      \rulecheckexp{\Sigma}{\Gamma'}{\tupleexp{}}{\tau'}
        \` \ruleref{\rulecheckexptuplename} \\
      \rulecheckassign{\Gamma}{A'}{\tupleexp{}}{A'}
        \` \ruleref{\rulecheckassigntuplename} \\
      \rulecheckloop{L}{\tupleexp{}}
        \` \ruleref{\rulechecklooptuplename} \- \\
    $\tau'' \not= \commandty$ \` No derivation of \ruletausmall{\commandty} \\
    \impliescmdreturn{\tau''}{\Sigma}{\Gamma}{e}{\tau'''}
      \` Vacuously true \\
    \rulecheckstate{\Sigma}{\stackframe{K'}{F'}}{\tau}{\lhd}{e} \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulesteploop] \ \\
  \newcommand{\looppushstack}{\frameloop{F}{e_c}{e}}
  \begin{tabbing}
  \rulegetframecontextdefaultconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulecheckexp{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\commandty}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulecheckassignloopconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulegetloopcontextdefaultconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulechecklooploopconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}} \\
  \rulecheckframetype{\Sigma}{A}{\looppushstack}{\commandty}{\tau''}
    \` \ruleref{\rulecheckframetypeframeexpnoretname} \\
  \\
  % Inner frame complete. Now show top is ok

  \rulegetframecontext{\Sigma}{\looppushstack}{\Gamma}
    \` \ruleref{\rulegetframecontextloopname} \\

  \rulecheckexp{\Sigma}{\Gamma}{e_c}{\bool}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\commandty} \\
  \rulecheckexp{\Sigma}{\Gamma}{e}{\commandty}
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\commandty} \\
  \rulecheckexp{\Sigma}{\Gamma}{\breakstm}{\commandty}
    \` \ruleref{\rulecheckexpbreakname} \\
  \rulecheckexp{\Sigma}{\Gamma}{\ifexp{e_c}{e}{\breakstm}}{\commandty}
    \` \ruleref{\rulecheckexpifname} \\
  \\

  \rulegetframeassigned{\looppushstack}{A}
    \` \ruleref{\rulegetframeassignedloopname} \\

  \rulecheckassign{\Gamma}{A}{e_c}{A}
    \` Inversion on \rulecheckassignloopconclusion{} \\
  \rulecheckassign{\Gamma}{A}{e}{A'}
    \` Inversion on \rulecheckassignloopconclusion{} \\
  \rulecheckassign{\Gamma}{A}{\breakstm}{A}
    \` \ruleref{\rulecheckassignbreakname} \\
  $A \cap A' = A$
    \` Lemma \ref{assignexpand} \\
  \rulecheckassign{\Gamma}{A}{\ifexp{e_c}{e}{\breakstm}}{A}
    \` \ruleref{\rulecheckassignifname} \\
  \\

  \rulegetloopcontext{\looppushstack}{\inloop}
    \` \ruleref{\rulegetloopcontextloopname} \\

  \rulecheckloop{L}{e_c}
    \` Inversion on \rulechecklooploopconclusion{} \\
  \rulecheckloop{\inloop}{e_c}
    \` Lemma \ref{loopsub} \\
  \rulecheckloop{\inloop}{e}
    \` Inversion on \rulechecklooploopconclusion{} \\
  \rulecheckloop{\inloop}{\breakstm}
    \` \ruleref{\rulecheckloopbreakname} \\
  \rulecheckloop{\inloop}{\ifexp{e_c}{e}{\breakstm}}
    \` \ruleref{\rulecheckloopifname} \\
  \\

  \ruledirok{\rhd}{\ifexp{e_c}{e}{\breakstm}}
    \` \ruleref{\ruledirokpushingname} \\

  \ruleonlyreturns{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''} \\
    \` Modus ponens with \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{e}{\tau''}
    \` Inversion on \ruleonlyreturns{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{\breakstm}{\tau''}
    \` \ruleref{\ruleonlyreturnsbreakname} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{\ifexp{e_c}{e}{\breakstm}}{\tau''}
    \` \ruleref{\ruleonlyreturnsifname} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\ifexp{e_c}{e}{\breakstm}}{\tau''}
    \` Trivial weakening \\

  \rulecheckstate{\Sigma}{\stackframe{K}{\looppushstack}}{\tau}{\rhd}{\ifexp{e_c}{e}{\breakstm}}
    \` \ruleref{\rulecheckstatenormalname} \\

  \end{tabbing}

\item[\rulesteplooppop] \ \\
  \newcommand{\looppopstack}{\frameloop{F}{e_c}{e}}
  \begin{tabbing}
  \rulegetloopcontextloopconclusion{}
    \` \ruleref{\rulegetloopcontextloopname} \\
  \rulegetinnerlooploopconclusion{}
    \` \ruleref{\rulegetinnerlooploopname} \\
  \rulegetframeassigned{\looppopstack}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckassignnopconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulegetframecontext{\Sigma}{\looppopstack}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckexp{\Sigma}{\Gamma}{\nop}{\commandty}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckframetype{\Sigma}{A}{\looppopstack}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\nop} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{\looppopstack}}{\tau}{\lhd}{\continue}
    \` \ruleref{\rulecheckstateloopcontname} \\
  \end{tabbing}

\item[\rulestepbreak] \ \\

  \begin{tabbing}
  \rulecheckloop{\inloop}{\breakstm}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulecheckassignbreakconclusion{}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulecheckexp{\Sigma}{\Gamma}{\breakstm}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  $\tau' = \commandty$
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\breakstm}{\tau'} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\breakstm} \\
  \rulegetinnerloop{F}{\frameloop{F'}{e_c}{e}} and \rulegetframeassigned{F'}{A'} and \\
  \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau''}
    \` Lemma \ref{innerloopcheck} \\
  \rulecheckframetype{\Sigma}{A'}{\frameloop{F'}{e_c}{e}}{\commandty}{\tau''}
    \` \ruleref{\rulecheckframetypeframeloopname} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\breakstm}
    \` \ruleref{\rulecheckstateloopbrkname} \\
  \end{tabbing}

\item[\rulestepbreakval] \ \\
  \newcommand{\breakvalstack}{\frameval{F}{x}{\tau_x}{v}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakvalstack}}{\tau}{\lhd}{\break} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakvalstack}}{\tau}{\lhd}{\break} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakvalstack}}{\tau}{\lhd}{\break} \\
  \rulegetloopcontext{\breakvalstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakvalstack}}{\tau}{\lhd}{\break} \\
  \rulegetinnerloop{\breakvalstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakvalstack}}{\tau}{\lhd}{\break} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\breakvalstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\breakvalstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\breakstm}
    \` \ruleref{\rulecheckstateloopbrkname} \\
  \end{tabbing}

\item[\rulestepbreakvar] \ \\
  \newcommand{\breakstmvarstack}{\framevar{F}{x}{\tau_x}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmvarstack}}{\tau}{\lhd}{\breakstm} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmvarstack}}{\tau}{\lhd}{\breakstm} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmvarstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetloopcontext{\breakstmvarstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmvarstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetinnerloop{\breakstmvarstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmvarstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\breakstmvarstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\breakstmvarstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\breakstm}
    \` \ruleref{\rulecheckstateloopbrkname} \\
  \end{tabbing}

\item[\rulestepbreakexp] \ \\
  \newcommand{\breakstmexpstack}{\frameexp{F}{e}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmexpstack}}{\tau}{\lhd}{\breakstm} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmexpstack}}{\tau}{\lhd}{\breakstm} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmexpstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetloopcontext{\breakstmexpstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmexpstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetinnerloop{\breakstmexpstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakstmexpstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\breakstmexpstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\breakstmexpstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\breakstm}
    \` \ruleref{\rulecheckstateloopbrkname} \\
  \end{tabbing}

\item[\rulestepbreakloop] \ \\
  \newcommand{\breakloopstack}{\frameloop{F}{e_c}{e}}
  \begin{tabbing}
  \rulegetinnerloop{\breakloopstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakloopstack}}{\tau}{\lhd}{\breakstm} \\
  $F' = \breakloopstack$
    \` Inversion on \rulegetinnerloop{\breakloopstack}{F'} \\
  \rulecheckframetype{\Sigma}{A}{\breakloopstack}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakloopstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\breakloopstack}{\commandty}{\tau''} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\breakloopstack}{\commandty}{\tau''} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\breakloopstack}}{\tau}{\lhd}{\breakstm} \\
  \rulegetframecontextdefaultconclusion{} for some $\Gamma$
    \` By construction \\
  \rulecheckvalnopconclusion{}
    \` \ruleref{\rulecheckvalnopname} \\
  \rulecheckexp{\Sigma}{\Gamma}{\nop}{\commandty}
    \` \ruleref{\rulecheckexpvaluename} \\
  \rulecheckassign{\Gamma}{A}{\nop}{A}
    \` \ruleref{\rulecheckassignvaluename} \\
  \rulegetloopcontext{F}{L} for some $L$
    \` By construction \\
  \rulecheckloop{L}{\nop}
    \` \ruleref{\rulecheckloopvaluename} \\
  \ruledirok{\lhd}{\nop}
    \` \ruleref{\ruledirokreturningname} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{\nop}{\tau''}
    \` \ruleref{\ruleonlyreturnsnopname} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\nop}{\tau''}
    \` Always true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\nop}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulestepcontinue] \ \\

  \begin{tabbing}
  \rulecheckloop{\inloop}{\continue}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulecheckassigncontinueconclusion{} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulegetframecontext{\Sigma}{F}{\Gamma}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulecheckexp{\Sigma}{\Gamma}{\continue}{\tau'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  $\tau' = \commandty$
    \` Inversion on \rulecheckexp{\Sigma}{\Gamma}{\continue}{\tau'} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\continue} \\
  \rulegetinnerloop{F}{\frameloop{F'}{e_c}{e}} and \rulegetframeassigned{F'}{A'} and \\
  \rulecheckframetype{\Sigma}{A'}{F'}{\commandty}{\tau''}
    \` Lemma \ref{innerloopcheck} \\
  \rulecheckframetype{\Sigma}{A'}{\frameloop{F'}{e_c}{e}}{\commandty}{\tau''}
    \` \ruleref{\rulecheckframetypeframeloopname} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\continue}
    \` \ruleref{\rulecheckstateloopcontname} \\
  \end{tabbing}

\item[\rulestepcontinueval] \ \\
  \newcommand{\continuevalstack}{\frameval{F}{x}{\tau_x}{v}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevalstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevalstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevalstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{\continuevalstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevalstack}}{\tau}{\lhd}{\continue} \\
  \rulegetinnerloop{\continuevalstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevalstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\continuevalstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\continuevalstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\continue}
    \` \ruleref{\rulecheckstateloopcontname} \\
  \end{tabbing}

\item[\rulestepcontinuevar] \ \\
  \newcommand{\continuevarstack}{\framevar{F}{x}{\tau_x}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevarstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevarstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevarstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{\continuevarstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevarstack}}{\tau}{\lhd}{\continue} \\
  \rulegetinnerloop{\continuevarstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continuevarstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\continuevarstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\continuevarstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\continue}
    \` \ruleref{\rulecheckstateloopcontname} \\
  \end{tabbing}

\item[\rulestepcontinueexp] \ \\
  \newcommand{\continueexpstack}{\frameexp{F}{e}}
  \begin{tabbing}
  \rulegetframeassigned{F'}{A}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueexpstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckframetype{\Sigma}{A}{F'}{\commandty}{\tau''}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueexpstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueexpstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{\continueexpstack}{\inloop}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueexpstack}}{\tau}{\lhd}{\continue} \\
  \rulegetinnerloop{\continueexpstack}{F'}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueexpstack}}{\tau}{\lhd}{\continue} \\
  \rulegetloopcontext{F}{\inloop}
    \` Inversion on \rulegetloopcontext{\continueexpstack}{\inloop} \\
  \rulegetinnerloop{F}{F'}
    \` Inversion on \rulegetinnerloop{\continueexpstack}{F'} \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\lhd}{\continue}
    \` \ruleref{\rulecheckstateloopcontname} \\
  \end{tabbing}

\item[\rulestepcontinueloop] \ \\
  \newcommand{\continueloopstack}{\frameloop{F}{e_c}{e}}
  \begin{tabbing}
  \rulegetinnerloop{\continueloopstack}{F'} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueloopstack}}{\tau}{\lhd}{\continue} \\
  $F' = \continueloopstack$
    \` Inversion on \rulegetinnerloop{\continueloopstack}{F'} \\
  \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueloopstack}}{\tau}{\lhd}{\continue} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''} \\
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulegetframeassigned{\continueloopstack}{A}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulegetframeassigned{F}{A}
    \` Inversion on \rulegetframeassigned{\continueloopstack}{A} \\
  \rulecheckframetype{\Sigma}{A}{F}{\commandty}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulecheckstack{\Sigma}{K}{\tau''}{\tau}
    \` Inversion on \rulecheckstate{\Sigma}{\stackframe{K}{\continueloopstack}}{\tau}{\lhd}{\continue} \\
  \rulegetframecontextdefaultconclusion{}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulecheckexploopconclusion{}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulecheckassign{\Gamma}{A'}{\loopstm{e_c}{e}}{A'}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulegetloopcontext{F}{L}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \rulechecklooploopconclusion{}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \ruledirok{\rhd}{\loopstm{e_c}{e}}
    \` \ruleref{\ruledirokpushingname} \\
  \ruleonlyreturns{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''}
    \` Inversion on \rulecheckframetype{\Sigma}{A}{\continueloopstack}{\commandty}{\tau''} \\
  \impliescmdreturn{\commandty}{\Sigma}{\Gamma}{\loopstm{e_c}{e}}{\tau''}
    \` Always true \\
  \rulecheckstate{\Sigma}{\stackframe{K}{F}}{\tau}{\rhd}{\loopstm{e_c}{e}}
    \` \ruleref{\rulecheckstatenormalname} \\
  \end{tabbing}

\item[\rulestepexnprop] \ \\

  \begin{tabbing}
  \rulecheckstate{\Sigma}{\cdot}{\tau}{\lhd}{\exn{}}
    \` \ruleref{\rulecheckstateexnname} \\
  \end{tabbing}

\end{description}
