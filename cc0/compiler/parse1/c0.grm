(* C0 Compiler
 * C0 grammar
 * Author: Frank Pfenning <fp@cs.cmu.edu>
 *)

structure A = Ast
structure PS = ParseState

fun location (NONE) = "_"
  | location (SOME(mark)) = Mark.show(mark)

(* mark e with region (left, right) in source file *)
fun mark (e, (left, right)) = A.Marked (Mark.mark' (e, PS.ext (left, right)))

fun marks (A.Assert(exp, nil), (left, right)) =
    let val ext = PS.ext (left, right)
    in
	A.Markeds (Mark.mark' (A.Assert(exp, [A.StringConst(location ext ^ ": assert failed")]),
			       ext))
    end 
  | marks (s, (left, right)) = A.Markeds (Mark.mark' (s, PS.ext (left, right)))

fun expand_arrow (exp, id) (left, right) =
      mark (A.Select (A.OpExp (A.DEREF, [exp]), id), (left, right))

fun resolve_scope ((nil, A.StmDecl(d)), [A.Seq(ds, ss)]) =
      [A.Seq(d::ds, ss)]
  | resolve_scope ((annos, A.StmDecl(d)), [A.Seq(ds, ss)]) =
      [A.Anno(annos), A.Seq(d::ds, ss)]
  | resolve_scope ((nil, A.StmDecl(d)), ss) =
      [A.Seq([d], ss)]
  | resolve_scope ((annos, A.StmDecl(d)), ss) =
      [A.Anno(annos), A.Seq([d], ss)]
  | resolve_scope ((nil, s), ss) = s::ss
  | resolve_scope ((annos, s), ss) = A.Anno(annos)::s::ss 

(* resolve_stm for conditionals only *)
fun resolve_annos (nil, s) = s
  | resolve_annos (annos, s) = A.Seq(nil, [A.Anno(annos), s])

fun resolve_stmts ([A.Seq(ds, ss)]) = A.Seq(ds, ss)
  | resolve_stmts (ss) = A.Seq([], ss)

fun error_starplusplus (exp) (left, right) =
      ( ErrorMsg.error (PS.ext (left, right))
          ("for compatibility with C, please write ( *e )++; instead of *e++;") ;
        raise ErrorMsg.Error )

fun error_starminusminus (exp) (left, right) =
      ( ErrorMsg.error (PS.ext (left, right))
          ("for compatibility with C, please write ( *e )--; instead of *e--;") ;
        raise ErrorMsg.Error )

fun expand_plusplus (exp) (left, right) =
      marks (A.Assign(SOME(A.PLUS), exp, A.IntConst(Word32.fromInt(1))), (left,right))

fun expand_minusminus (exp) (left, right) =
      marks (A.Assign(SOME(A.MINUS), exp, A.IntConst(Word32.fromInt(1))), (left,right))

fun mk_pragma (pragma_name, pragma_line) (left, right) =
      A.Pragma(A.Raw(pragma_name, pragma_line), PS.ext(left, right))

%%
%header (functor C0LrValsFn (structure Token : TOKEN))

%term 
   EOF
 | COMMA | COLON | SEMI | QUESTIONMARK
 | INTCONST of Word32.word
 | IDENT of Symbol.symbol
 | SPEC_IDENT of Symbol.symbol
 | TYPENAME of Symbol.symbol
 | STRINGCONST of string | CHARCONST of char
 | STRUCT | TYPEDEF | INT | BOOL | STRING | CHAR | VOID
 | IF | ELSE | WHILE | FOR | CONTINUE | BREAK | RETURN
 | TRUE | FALSE | NULL | ALLOC | ALLOC_ARRAY
 | PLUS | MINUS | STAR | SLASH | PERCENT
 | LESS | LESSEQ | GREATER | GREATEREQ | EQEQ | BANGEQ
 | AMPAMP | BARBAR | AMP | CARET | BAR | LL | GG
 | BANG | TILDE
 | DOT | ARROW
 | EQ | PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | PERCENTEQ
 | AMPEQ | CARETEQ | BAREQ | LLEQ | GGEQ
 | PLUSPLUS | MINUSMINUS
 | LBRACE | RBRACE
 | LPAREN | RPAREN
 | LBRACKET | RBRACKET
 | ANNO_BEGIN | ANNO_END
 | REQUIRES | ENSURES | LOOP_INVARIANT | ASSERT
 | BS_RESULT | BS_LENGTH | BS_OLD
 | UNARY | ASNOP (* dummy *)
 | PRAGMA of string * string

%nonterm 
   gdecl of A.gdecl
 | annos of A.spec list list
 | anno of A.spec list
 | specs of A.spec list
 | spec of A.spec
 | fields of A.field list
 | field of A.field
 | params of A.vardecl list
 | paramsx of A.vardecl list
 | param of A.vardecl
(*
 | decls of A.vardecl list
*)
 | decl of A.vardecl  (* list *)
 | tpe of A.tp
 | stmts of A.stm list
 | stmt of A.spec list * A.stm
 | simp of A.stm
 | simpopt of A.stm
 | loopbody of A.spec list * A.stm
 | body of A.stm
 | bodyOpt of A.stm
 | elseopt of A.stm
 | exps of A.exp list
 | expx of A.exp list
 | exp of A.exp
 | asnop of A.oper option
 | name of Symbol.symbol

%verbose                                (* print summary of errors *)
%pos int                                (* positions *)
%start gdecl				(* parse one declaration at a time *)
%eop EOF STRUCT TYPEDEF INT BOOL STRING CHAR VOID TYPENAME IDENT SEMI PRAGMA
		                        (* possible start symbols for next declaration *)
%noshift EOF

%name C0

%right ASNOP
%right QUESTIONMARK COLON
%left BARBAR
%left AMPAMP
%left BAR
%left CARET
%left AMP
%left EQEQ BANGEQ
%left LESS LESSEQ GREATER GREATEREQ
%left LL GG
%left PLUS MINUS
%left STAR SLASH PERCENT
%right UNARY
%left LPAREN LBRACKET ARROW DOT

%%

gdecl      : STRUCT name SEMI      (A.Struct(name, NONE, false, PS.ext(STRUCTleft, SEMIright)))
           | STRUCT name LBRACE fields RBRACE SEMI
	                           (A.Struct(name, SOME(fields), false, PS.ext(STRUCTleft, SEMIright)))
           | TYPEDEF tpe name      (A.TypeDef(name, tpe, PS.ext(TYPEDEFleft, nameright)))
		(* followed by SEMI; left implicit for incremental lexing/parsing purposes *)
           | tpe name LPAREN params RPAREN annos SEMI
                                   (A.Function(name, tpe, params, NONE, List.concat annos, false, PS.ext(tpeleft,SEMIright)))
           | tpe name LPAREN params RPAREN annos LBRACE stmts RBRACE
                                   (A.Function(name, tpe, params, SOME(resolve_stmts(stmts)),
					       List.concat annos, false, PS.ext(tpeleft,RBRACEright)))
           | PRAGMA                (mk_pragma PRAGMA (PRAGMAleft, PRAGMAright))

annos      :                       (nil)
           | anno annos            (anno::annos)

anno       : ANNO_BEGIN specs ANNO_END (specs)

specs      :                       (nil)
           | spec specs            (spec::specs)

spec       : REQUIRES exp SEMI     (A.Requires(exp, PS.ext(REQUIRESleft, SEMIright)))
           | ENSURES exp SEMI      (A.Ensures(exp, PS.ext(ENSURESleft, SEMIright)))
           | LOOP_INVARIANT exp SEMI  (A.LoopInvariant(exp, PS.ext(LOOP_INVARIANTleft, SEMIright)))
           | ASSERT exp SEMI       (A.Assertion(exp, PS.ext(ASSERTleft, SEMIright)))

fields     :                       (nil)
           | field fields          (field::fields)

field      : tpe name SEMI         (A.Field(name, tpe, PS.ext(tpeleft,SEMIright)))

params     :                       (nil)
           | param paramsx         (param::paramsx)
paramsx    :                       (nil)
           | COMMA param paramsx   (param::paramsx)

param      : tpe name              (A.VarDecl(name, tpe, NONE, PS.ext(tpeleft, nameright)))

(*
decls      :                       (nil)
           | decl decls            (decl::decls)
*)

decl       : tpe name              (A.VarDecl(name, tpe, NONE, PS.ext(tpeleft,nameright)))
           | tpe name EQ exp       (A.VarDecl(name, tpe, SOME(exp), PS.ext(tpeleft,expright)))

tpe        : INT                   (A.Int)
           | BOOL                  (A.Bool)
           | STRING                (A.String)
           | CHAR                  (A.Char)
           | VOID                  (A.Void)
           | tpe STAR              (A.Pointer(tpe))
           | tpe LBRACKET RBRACKET (A.Array(tpe))
           | TYPENAME              (A.TypeName(TYPENAME))
	   | STRUCT name           (A.StructName(name))				   

stmts      :                       (nil)
           | stmt stmts            (resolve_scope(stmt,stmts))

body       : simp SEMI             (simp)
	   | IF LPAREN exp RPAREN stmt elseopt
                                   (marks (A.If(exp, resolve_annos(stmt), elseopt), (IFleft, elseoptright)))
           | WHILE LPAREN exp RPAREN loopbody
                                   (marks (A.While(exp, #1 loopbody, #2 loopbody), (WHILEleft, loopbodyright)))
           | FOR LPAREN simpopt SEMI exp SEMI simpopt RPAREN loopbody
                                   (marks (A.For(simpopt1, exp, simpopt2, #1 loopbody, #2 loopbody), (FORleft, loopbodyright)))
           | CONTINUE SEMI         (marks (A.Continue, (CONTINUEleft, CONTINUEright)))
           | BREAK SEMI            (marks (A.Break, (BREAKleft, BREAKright)))
           | RETURN exp SEMI       (marks (A.Return(SOME(exp)), (RETURNleft, expright)))
           | RETURN SEMI           (marks (A.Return(NONE), (RETURNleft, SEMIright)))
	   | LBRACE stmts RBRACE   (marks (resolve_stmts(stmts), (LBRACEleft, RBRACEright)))
           | ASSERT LPAREN exp RPAREN SEMI (marks (A.Assert(exp, nil), (ASSERTleft, SEMIright)))

loopbody   : annos body            ((List.concat annos, body))

stmt       : body		   ((nil, body))
           | anno stmt             ((anno @ (#1 stmt), #2 stmt))

simp       : exp asnop exp %prec ASNOP
                                   (marks (A.Assign(asnop, exp1, exp2), (exp1left,exp2right)))
           | STAR exp PLUSPLUS     (error_starplusplus(exp) (STARleft, PLUSPLUSright))
           | STAR exp MINUSMINUS   (error_starminusminus(exp) (STARleft, MINUSMINUSright))
           | exp PLUSPLUS          (expand_plusplus (exp) (expleft, PLUSPLUSright))
           | exp MINUSMINUS        (expand_minusminus (exp) (expleft, MINUSMINUSright))
           | exp                   (marks (A.Exp(exp), (expleft,expright)))
           | decl                  (A.StmDecl(decl)) (* do not mark so we can pattern-match *)

simpopt    :                       (A.Seq(nil,nil))
           | simp                  (simp)


elseopt    :                       (A.Seq(nil,nil))
           | ELSE stmt             (resolve_annos(stmt))


exp        : LPAREN exp RPAREN     (exp)
           | INTCONST              (mark (A.IntConst(INTCONST),(INTCONSTleft,INTCONSTright)))
           | STRINGCONST           (mark (A.StringConst(STRINGCONST),(STRINGCONSTleft,STRINGCONSTright)))
           | CHARCONST             (mark (A.CharConst(CHARCONST),(CHARCONSTleft,CHARCONSTright)))
           | TRUE                  (mark (A.True,(TRUEleft,TRUEright)))
           | FALSE                 (mark (A.False,(FALSEleft,FALSEright)))
           | NULL                  (mark (A.Null,(NULLleft,NULLright)))
           | IDENT                 (mark (A.Var(IDENT), (IDENTleft,IDENTright)))
           | IDENT LPAREN exps RPAREN (mark (A.FunCall(IDENT, exps), (IDENTleft, RPARENright)))
           | BS_RESULT             (mark (A.Result, (BS_RESULTleft, BS_RESULTright)))
	   | BS_LENGTH LPAREN exp RPAREN (mark (A.Length(exp), (BS_LENGTHleft, RPARENright)))
	   | BS_OLD LPAREN exp RPAREN (mark (A.Old(exp), (BS_OLDleft, RPARENright)))
           | exp PLUS exp          (mark (A.OpExp (A.PLUS, [exp1,exp2]), (exp1left,exp2right)))
           | exp MINUS exp         (mark (A.OpExp (A.MINUS, [exp1,exp2]), (exp1left,exp2right)))
           | exp STAR exp          (mark (A.OpExp (A.TIMES, [exp1,exp2]), (exp1left,exp2right)))
           | exp SLASH exp         (mark (A.OpExp (A.DIVIDEDBY, [exp1,exp2]), (exp1left,exp2right)))
           | exp PERCENT exp       (mark (A.OpExp (A.MODULO, [exp1,exp2]), (exp1left,exp2right)))
           | exp DOT name          (mark (A.Select (exp,name), (expleft, nameright)))
           | exp LBRACKET exp RBRACKET
                                   (mark (A.OpExp (A.SUB, [exp1,exp2]), (exp1left, RBRACKETright)))
           | exp ARROW name        (expand_arrow (exp, name) (expleft, nameright))
           | ALLOC LPAREN tpe RPAREN (mark (A.Alloc(tpe), (ALLOCleft, RPARENright)))
           | ALLOC_ARRAY LPAREN tpe COMMA exp RPAREN
                                   (mark (A.AllocArray(tpe,exp), (ALLOC_ARRAYleft, RPARENright)))
           | exp LL exp            (mark (A.OpExp (A.SHIFTLEFT, [exp1, exp2]), (exp1left, exp2right)))
           | exp GG exp            (mark (A.OpExp (A.SHIFTRIGHT, [exp1, exp2]), (exp1left, exp2right)))
           | exp LESS exp          (mark (A.OpExp (A.LESS, [exp1, exp2]), (exp1left, exp2right)))
           | exp LESSEQ exp        (mark (A.OpExp (A.LEQ, [exp1, exp2]), (exp1left, exp2right)))
           | exp GREATER exp       (mark (A.OpExp (A.GREATER, [exp1, exp2]), (exp1left, exp2right)))
           | exp GREATEREQ exp     (mark (A.OpExp (A.GEQ, [exp1, exp2]), (exp1left, exp2right)))
           | exp EQEQ exp          (mark (A.OpExp (A.EQ, [exp1, exp2]), (exp1left, exp2right)))
           | exp BANGEQ exp        (mark (A.OpExp (A.NOTEQ, [exp1, exp2]), (exp1left, exp2right)))
           | exp AMP exp           (mark (A.OpExp (A.AND, [exp1, exp2]), (exp1left, exp2right)))
           | exp CARET exp         (mark (A.OpExp (A.XOR, [exp1, exp2]), (exp1left, exp2right)))
           | exp BAR exp           (mark (A.OpExp (A.OR, [exp1, exp2]), (exp1left, exp2right)))
           | exp AMPAMP exp        (mark (A.OpExp (A.LOGAND, [exp1, exp2]), (exp1left, exp2right)))
           | exp BARBAR exp        (mark (A.OpExp (A.LOGOR, [exp1, exp2]), (exp1left, exp2right)))
           | exp QUESTIONMARK exp COLON exp
                                   (mark (A.OpExp (A.COND, [exp1, exp2, exp3]), (exp1left, exp3right)))
           | BANG exp %prec UNARY  (mark (A.OpExp (A.LOGNOT, [exp]), (BANGleft, expright)))
           | TILDE exp %prec UNARY (mark (A.OpExp (A.COMPLEMENT, [exp]), (TILDEleft, expright)))
           | MINUS exp %prec UNARY (mark (A.OpExp (A.NEGATIVE, [exp]), (MINUSleft,expright)))
           | STAR exp %prec UNARY  (mark (A.OpExp (A.DEREF, [exp]), (STARleft,expright)))

exps       :                       (nil)
           | exp expx              (exp::expx)
expx       :                       (nil)
           | COMMA exp expx        (exp::expx)

asnop      : EQ                    (NONE)
           | PLUSEQ                (SOME(A.PLUS))
           | MINUSEQ               (SOME(A.MINUS))
           | STAREQ                (SOME(A.TIMES))
           | SLASHEQ               (SOME(A.DIVIDEDBY))
           | PERCENTEQ             (SOME(A.MODULO))
           | AMPEQ                 (SOME(A.AND))
           | CARETEQ               (SOME(A.XOR))
           | BAREQ                 (SOME(A.OR))
           | LLEQ                  (SOME(A.SHIFTLEFT))
           | GGEQ                  (SOME(A.SHIFTRIGHT))

name       : IDENT                 (IDENT)
           | TYPENAME              (TYPENAME)
