local
    val pc_next = ref ~1
    val poss = ref [] : Mark.ext list ref
in
    fun pc left right = 
	(pc_next := !pc_next + 1;
	 poss := !poss @ [valOf (ParseState.ext (left,right))];
	 !pc_next
	)

    fun reset () = pc_next := ~1 before poss := []

    fun get_positions () = 
	let
	    val positions = !poss
	    val _ = reset()
	in
	    Vector.fromList positions
	end
end

%%
%header (functor C0LrValsFn (structure Token : TOKEN))

%term 
   EOF
 | SEMI
 | INTCONST of Word32.word
 | STRINGCONST of string
 | CHARCONST of char
 | IDENT of string
 | TYPE_IDENT of string
 | RETURN
 | COLON | COMMA | QMARK | ARROW | PERIOD
 | IF
 | ELSE
 | WHILE
 | FOR
 | CONTINUE
 | BREAK
 | STRUCT
 | VOID | INT | BOOL | STRING | CHAR
 | NULL | TRUE | FALSE
 | ALLOC | ALLOCARRAY
 | TYPEDEF
 | PLUS | MINUS
 | PLUSPLUS | MINUSMINUS
 | STAR
 | SLASH | PERCENT
 | LT | LTEQ | GT | GTEQ | EQEQ | BANGEQ
 | AMPERAMPER | BARBAR | AMPER | BAR | CAROT | LTLT | GTGT
 | EQ | PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | PERCENTEQ
 | AMPEREQ | BAREQ | CAROTEQ | LTLTEQ | GTGTEQ
 | AMPERAMPEREQ | BARBAREQ
 | LBRACE | RBRACE
 | LPAREN
 | RPAREN
 | LBRACK | RBRACK
 | BANG | TILDE

%nonterm
    const of C0.constant
  | var_name of C0.variable_name
  | fun_name of C0.function_name
  | type_name of C0.type_name
  | new_type_name of C0.type_name
  | struct_name of C0.field_name
  | field_name of C0.field_name
  | struct_decl of C0.struct_decl
  | struct_def of C0.struct_def
  | struct_fields of (C0.ty * C0.field_name) list
  | field_decl of C0.ty * C0.field_name
  | ty of C0.ty
  | function_decl of C0.function_decl
  | paramlist of (C0.ty * C0.variable_name) list
  | assop of C0.assignop
  | posop of C0.postop
  | exp of C0.exp
  | call_exp of C0.call_expression
  | explist of C0.exp list
  | lhs of C0.lhs
  | simp of C0.simple_statement
  | statement of C0.statement
  | statement_list of C0.statement list
  | decl of C0.decl
  | gdecl of C0.decl list
  | program of C0.decl list * Mark.ext Vector.vector

%pos int
%start program
%eop EOF
%noshift EOF
%verbose

%name C0

%right EQ PLUSEQ MINUSEQ STAREQ SLASHEQ PERCENTEQ AMPEREQ BAREQ CAROTEQ LTLTEQ GTGTEQ
%right QMARK COLON
%left BARBAR
%left AMPERAMPER
%left BAR
%left CAROT
%left AMPER
%left EQEQ BANGEQ
%left LT LTEQ GT GTEQ
%left LTLT GTGT
%left PLUS MINUS
%left STAR SLASH PERCENT
%right BANG TILDE
%left LPAREN LBRACK ARROW PERIOD

%%

const : NULL (C0.NullPointer)
      | INTCONST (C0.Int INTCONST)
      | TRUE (C0.Bool true)
      | FALSE (C0.Bool false)
      | STRINGCONST (C0.String STRINGCONST)
      | CHARCONST (C0.Char CHARCONST)

var_name : IDENT (C0.Normal IDENT)
fun_name : IDENT (IDENT)
new_type_name : IDENT (IDENT)
type_name : TYPE_IDENT (TYPE_IDENT)
struct_name : IDENT (IDENT)
	    | TYPE_IDENT (TYPE_IDENT)
field_name : IDENT (IDENT)
	   | TYPE_IDENT (TYPE_IDENT)

struct_decl : STRUCT struct_name (struct_name)

struct_def : struct_decl LBRACE struct_fields RBRACE (struct_decl, struct_fields)

struct_fields : ([])
	      | field_decl struct_fields (field_decl :: struct_fields)

field_decl : ty field_name SEMI (ty, field_name)

ty : type_name (C0.TyVar type_name)
   | VOID (C0.TyUnit)
   | BOOL (C0.TyBool)
   | INT (C0.TyInt)
   | STRING (C0.TyString)
   | CHAR (C0.TyChar)
   | ty STAR (C0.TyPointer ty)
   | ty LBRACK RBRACK (C0.TyArray ty)
   | struct_decl (C0.TyStruct struct_decl)

function_decl : ty fun_name LPAREN RPAREN (ty, fun_name, [])
	      | ty fun_name LPAREN paramlist RPAREN (ty, fun_name, paramlist)

paramlist : ty var_name ([(ty, var_name)])
	  | ty var_name COMMA paramlist ((ty, var_name) :: paramlist)

assop : EQ (NONE)
      | PLUSEQ (SOME (C0.Plus))
      | MINUSEQ (SOME (C0.Minus))
      | STAREQ (SOME (C0.Times))
      | SLASHEQ (SOME (C0.Div))
      | PERCENTEQ (SOME (C0.Mod))
      | AMPEREQ (SOME (C0.BitAnd))
      | CAROTEQ (SOME (C0.BitXor))
      | BAREQ (SOME (C0.BitOr))
      | LTLTEQ (SOME (C0.ShiftLeft))
      | GTGTEQ (SOME (C0.ShiftRight))

posop : PLUSPLUS (C0.Inc)
      | MINUSMINUS (C0.Dec)

exp : LPAREN exp RPAREN (exp)
    | const (C0.Const const)
    | var_name (C0.Var var_name)

    | BANG exp (C0.Monop (C0.LogicNot, exp))
    | MINUS exp (C0.Monop (C0.ArithNeg, exp))
    | TILDE exp (C0.Monop (C0.BitNot, exp))

    | exp STAR exp (C0.Binop (exp1, C0.Times, exp2))
    | exp SLASH exp (C0.Binop (exp1, C0.Div, exp2))
    | exp PERCENT exp (C0.Binop (exp1, C0.Mod, exp2))
    | exp PLUS exp (C0.Binop (exp1, C0.Plus, exp2))
    | exp MINUS exp (C0.Binop (exp1, C0.Minus, exp2))
    | exp LTLT exp (C0.Binop (exp1, C0.ShiftLeft, exp2))
    | exp GTGT exp (C0.Binop (exp1, C0.ShiftRight, exp2))
    | exp LT exp (C0.Binop (exp1, C0.Lt, exp2))
    | exp LTEQ exp (C0.Binop (exp1, C0.Leq, exp2))
    | exp GT exp (C0.Binop (exp1, C0.Gt, exp2))
    | exp GTEQ exp (C0.Binop (exp1, C0.Geq, exp2))
    | exp EQEQ exp (C0.Binop (exp1, C0.Eq, exp2))
    | exp BANGEQ exp (C0.Binop (exp1, C0.Neq, exp2))
    | exp AMPER exp (C0.Binop (exp1, C0.BitAnd, exp2))
    | exp CAROT exp (C0.Binop (exp1, C0.BitXor, exp2))
    | exp BAR exp (C0.Binop (exp1, C0.BitOr, exp2))
    | exp AMPERAMPER exp (C0.Binop (exp1, C0.LogicAnd, exp2))
    | exp BARBAR exp (C0.Binop (exp1, C0.LogicOr, exp2))

    | STAR exp (C0.Ref exp)
    | exp LBRACK exp RBRACK (C0.Index (exp1, exp2))
    | call_exp (C0.Call (call_exp))
    | exp ARROW field_name (C0.RefField (exp, field_name))
    | exp PERIOD field_name (C0.Field (exp, field_name))
    | exp QMARK exp COLON exp (C0.Ternary (exp1, exp2, exp3))
    | ALLOC LPAREN ty RPAREN (C0.Alloc ty)
    | ALLOCARRAY LPAREN ty COMMA exp RPAREN (C0.AllocArray (ty, exp))

call_exp : exp LPAREN RPAREN (C0.Func (exp, [], pc expleft RPARENright))
	 | exp LPAREN explist RPAREN (C0.Func (exp, explist, pc expleft RPARENright))

explist : exp ([exp])
	| exp COMMA explist (exp :: explist)

simp : exp assop exp (C0.Assign (exp1, assop, exp2, pc expleft expright))
     | call_exp (C0.SimpleCall call_exp)
     | exp posop (C0.Postop (exp, posop, pc expleft posopright))
     | (C0.Noop)

statement : ty var_name SEMI (C0.Decl (ty, var_name, NONE, pc tyleft var_nameright))
	  | ty var_name EQ exp SEMI (C0.Decl (ty, var_name, SOME exp, pc tyleft expright))
	  | simp SEMI (C0.Simple simp)
	  | RETURN SEMI (C0.Return (NONE, pc RETURNleft RETURNright))
	  | RETURN exp SEMI (C0.Return (SOME exp, pc RETURNleft expright))
	  | BREAK SEMI (C0.Break (pc BREAKleft BREAKright))
	  | CONTINUE SEMI (C0.Continue (pc CONTINUEleft CONTINUEright))
	  | IF LPAREN exp RPAREN statement (C0.If (exp, pc expleft expright, statement, NONE))
	  | IF LPAREN exp RPAREN statement ELSE statement 
		(C0.If (exp, pc expleft expright, statement1, SOME statement2))
	  | WHILE LPAREN exp RPAREN statement (C0.While (exp, pc expleft expright, statement))
	  | FOR LPAREN simp SEMI SEMI simp RPAREN statement (C0.For (simp1, NONE, simp2, statement))
	  | FOR LPAREN simp SEMI exp SEMI simp RPAREN statement 
		(C0.For (simp1, SOME (exp, pc expleft expright), simp2, statement))
	  | LBRACE statement_list RBRACE (C0.Compound statement_list)

statement_list : ([])
	       | statement statement_list (statement :: statement_list)
	  
decl : struct_decl SEMI (C0.DeclStructDecl struct_decl)
     | struct_def SEMI (C0.DeclStructDef struct_def)
     | TYPEDEF ty new_type_name SEMI (C0.DeclTypeDefTy (ty, new_type_name))
     | function_decl SEMI (C0.DeclFunDecl function_decl)
     | function_decl LBRACE statement_list RBRACE (C0.DeclFunDef (function_decl, statement_list))

gdecl : ([]) 
      | decl gdecl (decl :: gdecl)

program : gdecl (gdecl, get_positions())


